Looking at the start function, first it calls a function, then exists the process if the returned value isn't 0. If the returned value is 0,  it will call a few functions and create a thread, after that it will call 2 other functions and end the program.
![[Pasted image 20240829073828.png]]

We can see that the first function `loc_40ac24` creates a mutex called `sync-z-mtx-133` and returns a non-zero value if there is an error, let's rename the function to `create_mutex`.
![[Pasted image 20240829074712.png]]

The next subroutine `sub_40a120` simply sets the Winsock library, let's rename it the `set_winsock_library`.
![[Pasted image 20240829075036.png]]

The next subroutine `sub_40A247` Retrieves the number of milliseconds that have elapsed since the system was started, up to 49.7 days as per Microsoft documentation, let's rename it to `calculate_time`. It then moves the value from the eax register to `dword_40C0A0`, let's rename this variable to `elapsedTime`.
![[Pasted image 20240829075705.png]]

The subroutine `sub_40ACD0` doesn't seem important.

The next subroutine `sub_40A7A3` gets the fully qualified path for the intrenat.exe file using the `GetModuleFileNameA` WINAPI, and then uses the `lstrcpyA` WINAPI to load the string into the buffer. It then appends the path and the file name together.
![[Pasted image 20240829090419.png]]

The function then checks if the path exists, if it is it gets the path for the temporary directory, else it gets the path for the system directory. It then checks that the file path starts with a valid byte.
![[Pasted image 20240829091454.png]]

If the starting byte isn't valid, it changes it to a valid path, sets file attributes, and creates the file.

The purpose of the function is to create the file, lets rename it to `create_executable`.

The next subroutine `sub_40A908` first gets a subkey and opens a registry key that represents `KEY_READ` access, if it's not successful it will try again with a different key that represents `KEY_WRITE` access, and then exit the function if it's not successful again.
![[Pasted image 20240829094750.png]]

The function then sets the registry key with the name of String1 and to the value from lpString and closes the key.

The next subroutine `sub_40A5AD` first compares the value of String 1 to the ASCII value of the letter 'z', if it's below it'll look for a network drive and write bytes using the subroutine `sub_40A565` to the file intrenat.exe file from before.
![[Pasted image 20240829102214.png]]

If the value is above or equal to 'z', the function will chain String1 with `sync-src-1.00.tbz`. A quick Google search shows us that we are dealing with the DoomJuice.exe malware, from [this link](https://any.run/report/5b7228947b256f36bd98dde1622799cda8f7a7aa0f3196aba08200fe8439dfee/28266913-725e-48b7-9847-420fb8ac3458) we can see details such as registry keys modified. The subroutine then writes bytes to 4 different paths. Let's rename the function to `persistence`.

The start function then creates a thread and calls to two additional functions.

The first function is the same persistence function from above.

Let's check the last subroutine in start, `sub_40A4B4`.

The first function it calls is `sub_40A26B`, this subroutine seems to do mostly initialization tasks.

After some more initialization related tasks, the `sub_40A4B4` creates a new thread and gets the host name. It then calls the subroutine `sub_40ACD0`.

The subroutine `sub_40ACD0` sets the proper variable values.

The next subroutine `sub_40A2CB` first calls the subroutine `sub_40AC90`, this function sets the parameters.

The subroutine `sub_40A2CB` then gets the hostname. It then compares to values and if they are equal it jumps to the end of the function.

Else it will create a file, read it, and send it.

Let's now check the last subroutine in `sub_40A418`, the subroutine `sub_40A418`.
![[Pasted image 20240829114630.png]]

It first gets the current thread, gets its priority and calls the subroutine `sub_40ACD0`, this subroutine is simply for initialization tasks.

It then calls the subroutine `sub_40A26B` to get the module handle of `wininet.dll`, load the library, and get the address of the process.

Next it calls the subroutine `sub_40A418` which is used to send the data. This subroutine runs a infinite loop of sending data.

Overall the subroutine `sub_40A4B4` is used to initialize the data sending.