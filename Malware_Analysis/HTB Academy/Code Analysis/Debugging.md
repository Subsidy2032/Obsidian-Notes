Debugging adds a dynamic, interactive layer to code analysis, offering a real-time view of malware behavior. It empowers analysis to confirm their discoveries, witness runtime impacts, and deepen their comprehension of the program execution. Uniting code analysis and debugging allows for a comprehensive understanding of the malware, leading to the effective disclosure of harmful behavior.

We can use x64dbg for debugging purposes. It comes equipped with graphical interface for visualizing disassembled code, implementing breakpoints, examining memory and registers, and controlling the execution of programs.

Here's how to run a sample within `x64dbg` to familiarize with its operations.

- Launch `x64dbg`.
- At the top of the `x64dbg` interface, click the `File` menu.
- Select `Open` to choose the executable file we wish to debug.
- Browse to the directory containing the executable and select it.
- Optionally, command-line arguments or the working directory can be specified in the dialog box that appears.
- Click `OK` to load the executable into `x64dbg`.

Upon opening, the default window halts at a default breakpoint at the program's entry point.
![[x64dbg_001_views.webp]]

Loading an executable into `x64dbg` reveals the disassembly view, showcasing the assembly instructions of the program, thereby aiding in understanding the code flow. To the right, the register window divulges the values of CPU registers, shedding light on the program's state. Beneath the register window, the stack view displays the current stack frame, enabling the inspection of function calls and local variables. Lastly, on the bottom left corner, we find the memory dump view, providing a pictorial representation of the program's memory, facilitating the analysis of data structures and variables.

## Simulating Internet Services

The role of INetSim in simulating typical network services in our restricted testing environment is pivotal. It offers support for a multitude of services, encompassing DNS, HTTP, FTP, SMTP, among others. We can fine tune it to reproduce specific responses, thereby enabling a more tailored examination of the malware behavior.

We should configure `INetSim` as follows.
```shell-session
$ sudo nano /etc/inetsim/inetsim.conf
```

The below need to be uncommented and specified.
```shell-session
service_bind_address <Our machine's/VM's TUN IP>
dns_default_ip <Our machine's/VM's TUN IP>
dns_default_hostname www
dns_default_domainname iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com
```

Initiating `INetSim` involves executing the following command.
```shell-session
$ sudo inetsim 
INetSim 1.3.2 (2020-05-19) by Matthias Eckert & Thomas Hungenberg
Using log directory:      /var/log/inetsim/
Using data directory:     /var/lib/inetsim/
Using report directory:   /var/log/inetsim/report/
Using configuration file: /etc/inetsim/inetsim.conf
Parsing configuration file.
Configuration file parsed successfully.
=== INetSim main process started (PID 34711) ===
Session ID:     34711
Listening on:   0.0.0.0
Real Date/Time: 2023-06-11 00:18:44
Fake Date/Time: 2023-06-11 00:18:44 (Delta: 0 seconds)
 Forking services...
  * dns_53_tcp_udp - started (PID 34715)
  * smtps_465_tcp - started (PID 34719)
  * pop3_110_tcp - started (PID 34720)
  * smtp_25_tcp - started (PID 34718)
  * http_80_tcp - started (PID 34716)
  * ftp_21_tcp - started (PID 34722)
  * https_443_tcp - started (PID 34717)
  * pop3s_995_tcp - started (PID 34721)
  * ftps_990_tcp - started (PID 34723)
 done.
Simulation running.
```

A more elaborate resource on configuring `INetSim` is the following: [https://medium.com/@xNymia/malware-analysis-first-steps-creating-your-lab-21b769fb2a64](https://medium.com/@xNymia/malware-analysis-first-steps-creating-your-lab-21b769fb2a64)

Finally, the spawned target's DNS should be pointed to the machine/VM where `INetSim` is running.
![[point_.webp]]

## Applying the Patches to Bypass Sandbox Checks

We want circumvent the sandbox detection while debugging with x64dbg. There are several methods to get to the instructions of where sandbox detection is performed, we will discuss a few of those.

### By Copying the Address from IDA

During code analysis, we observed the sandbox detection check related to the registry key. We can extract the address of the first `cmp` instruction directly from `IDA`.

We can open the function we renamed to `assumed main` and look for the `cmp` instruction. We can switch to text view in order to see the address.

We can copy the address `00000000004032C8` from `IDA`.
```ida
.text:00000000004032C8                 cmp     [rsp+148h+Type], 1
```

In `x64dbg`, we can right-click anywhere on the disassembly view (CPU) and select `Go to` > `Expression`. Alternatively, we can press `Ctrl+G` (go to expression) as a shortcut.

We can enter the copied address here, as shown in the screenshot. This navigates us to the comparison instruction where we can implement changes.
![[ida_027_addresscp.webp]]

### By Searching Through the Strings

We can look for `Sandbox detected` in the `String references`, and set a breakpoint so the execution will pause there.

To do this, first click on the `Run` button once and then right-click anywhere on the disassembly view, and choose `Search for` > `Current Module` > `String references`.
![[x64dbg_002_strings_.webp]]

Next, we can add a breakpoint to mark the location, then study the instructions before this Sandbox `MessageBox` to discern how the jump was made to the instruction printing `Sandbox detected`.

Let's start by adding a breakpoint at the last `Sandbox detected` string as follows.
![[x64dbg_002_strings__.webp]]

We can then double-click on the string to go to the address where the instructions to print `Sandbox detected` are located.
![[x64dbg_003_cmp.webp]]

There is a `cmp` instruction above the message box which compares the value with `1` after a registry path comparison has been performed. Let's modify this comparison to match with `0` instead. This can be done by placing the cursor on that instruction and pressing `Spacebar` on the keyboard. This allows us to edit the assembly code instructions.
![[x64dbg_004_assemble_patch1.webp]]

We can change the comparison value of `0x1` to `0x0`. Changing the comparison to `0` may shift the control flow of the code, and it should not jump to the address where `MessageBox` is displayed.
![[x64dbg_004_patch1.webp]]

Upon clicking on `Run` in `x64dbg` or pressing `F9`, it won't hit the breakpoint for the first sandbox detection message code. This means that we successfully patched the instructions.

In a similar manner, we can add a breakpoint on the next sandbox detection function before it prints a `MessageBox` as well. The breakpoint should be placed at the `second to last` `Sandbox detected` string (`0000000000402F13`). We can notice that there is a `jump` instruction we can skip, directing the execution flow to the next instruction that calls another function.
![[x64dbg_005_patch2.webp]]

We can alter the instruction from `je shell.402F09` to `jne shell.402F09`.
![[x64dbg_006_jne.webp]]

`shell.exe` performs sandbox detection by checking for internet connectivity. This section's target doesn't have internet connectivity. For this reason we should patch this sandbox detection method as well. We can do that by clicking on the first `Sandbox detected` string (`0000000000402CBD`) and patching the following instruction.
![[patch3.webp]]

![[patch3_.webp]]

Now, when we press `Run`, the patched `shell.exe` proceeds further, downloads the default executable from `INetSim`, and executes it.
![[both_messagebox.webp]]

With the sandbox checks bypassed, the actual functionality is unveiled. We can save the patched executable by pressing `Ctrl+P` and clicking on `Patch File`. This action stores the patched file, which skips the sandbox checks.
![[patch3__.webp]]

We undertake this process to ensure that the next time we run the saved patched file, it executes directly without the sandbox checks, and we can observe all the events in `ProcessMonitor`.

## Analyzing Malware Traffic

Keep in mind that traffic analysis not only can be, but ideally should be incorporated as an integral part of Dynamic Analysis.

Let's now employ `Wireshark` to examine the network traffic generated by the malware. Be minded to the color coded traffic: red corresponds to client-to-server traffic, while blue denotes the server-to-client exchange.

Examining the HTTP Request reveals that the malware sample appends the computer hostname to the user agent field (in this case it was `RDSEMVM01`).
![[wireshark_request.webp]]

When inspecting the HTTP Response, it becomes evident that `InetSim` has returned its default binary as a response to the malware.
![[wireshark_response.webp]]

The malware's request for `svchost.exe` solicits the default binary from `InetSim`. This binary responds with a `MessageBox` featuring the message: `This is the INetSim default binary`.

Additionally, DNS requests for a random domain and the address `ms-windows-update[.]com` were sent by the malware, with `INetSim` responding with fake responses (in this case `INetSim` was running on `10.10.10.100`).
![[wireshark_dns.webp]]

## Analyzing Process Injection & Memory Region

On the journey of code analysis, we discovered that our executable performs process injection on `notepad.exe` and displays a `MessageBox` stating `Connection sent to C2`.

To probe deeper into the process injection. we can set breakpoints at WINAPI functions `VirtualAllocEx`, `WriteProcessMemory`, and `CreateRemoteThread`. It will allow us to scrutinize the content held in the registers during process injection. Here is the procedure to set these breakpoints:

- Access the `x64dbg` interface and navigate to the `Symbols` tab, located at the top.
- In the symbol search box, search for the desired DLL name on the left and function names, such as `VirtualAllocEx`, `WriteProcessMemory`, and `CreateRemoteThread`, on the right within the `Kernel32.dll` DLL.
- As the function names materialize in the search results, right-click and select `Toggle breakpoint` from the context menu for each function. An alternative shortcut is to press `F2`.

Executing these steps sets a breakpoint at each function's entry point. We'll replicate these steps for all the functions we intend to scrutinize.
![[x64dbg_008_bp_wpm.webp]]

After setting breakpoints, we press `F9` or select `Run` from the toolbar until we reach the breakpoint for `WriteProcessMemory`. Up until this moment, `notepad` has been launched, but the `shellcode` has not yet been written into notepad's memory.

### Attaching Another Running Process in x64dbg

In order to delve further, let's open another instance of `x64dbg` and attach it to `notepad.exe`.

- Start a new instance of `x64dbg`.
- Navigate to the `File` menu and select `Attach` or use the `Alt + A` keyboard shortcut.
- In the `Attach` dialog box, a list of running processes will appear. Choose `notepad.exe` from the list.
- Click the `Attach` button to begin the attachment process.

Once the attachment is successful, `x64dbg` initiates the debugging of the target process, and the main window displays the assembly code along with other debugging information.

Now, we can establish breakpoints, step through the code, inspect registers and memory, and study the behavior of the attached notepad.exe process using `x64dbg`.
![[x64dbg_009_attach.webp]]

The 2nd argument of `WriteProcessMemory` is `lpBaseAddress` which contains a pointer to the base address in the specified process to which data is written. In our case, it should be in the `RDX` register.
![[msdn_002_writeprocessmemory.webp]]

When invoking the `WriteProcessMemory` function, the `rdx` register holds the `lpBaseAddress` parameter. This parameter represents the address within the target process's address space where the data will be written.

We aim to examine the registers when the `WriteProcessMemory` function is invoked in the `x64dbg` instance running the `shell.exe` process. This will reveal the address within `notepad.exe` where the shellcode will be written.
![[x64dbg_010_register_wpm.webp]]

We copy this address to examine its content in the memory dump of the attached `notepad.exe` process in the second `x64dbg` instance.

We now select `Go to` > `Expression` by right-clicking anywhere on the memory dump in the second `x64dbg` instance running `notepad.exe`.

With the copied address entered, the content at this address is displayed (by right-clicking on the address and choosing `Follow in Dump` > `Selected Address`), which currently is empty.
![[x64dbg_011_shellcode_write.webp]]

Next, we execute shell.exe in the first `x64dbg` instance by clicking on the `Run` button. We observe what is inscribed into this memory region of `notepad.exe`.
![[x64dbg_shellcodecopy_.webp]]

Following its execution, we identify the injected `shellcode`, which aligns with what we discovered earlier during code analysis. We can verify this in `Process Hacker` and save it to a file for subsequent examination.