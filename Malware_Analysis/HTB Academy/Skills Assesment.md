Here is the MD5 hash of the file.
```powershell
PS C:\Users\htb-student\Desktop\additional_samples> Get-FileHash -Algorithm MD5 .\apple.exe

Algorithm       Hash                                                                   Path
---------       ----                                                                   ----
MD5             1C7243C8F3586B799A5F9A2E4200AA92                                       C:\Users\htb-student\Desktop\additional_samples\apple.exe
```

It doesn't appear that the malware uses a packing techniques from the `strings` command.
```powershell
PS C:\Users\htb-student\Desktop\additional_samples> strings .\apple.exe

Strings v2.54 - Search for ANSI and Unicode strings in binary images.
Copyright (C) 1999-2021 Mark Russinovich
Sysinternals - www.sysinternals.com

!This program cannot be run in DOS mode.
S{@
Rich
.text
`.rdata
@.data
.pdata
@.rsrc
@.reloc
WATAUH
t{H
tkH
\$@H
l$HH
t$PH
 A]A\_
@SWH
\$`
H_[
t$p
t$p
H_[
d$@
\$0H
\$(H
l$h
D$
L$`I
\$
l$hL
d$@H
t$p
H_[
USVATH
U0H
E0H
E@H
E8H
|$pL

<SNIP>

GetProcessWindowStation
GetUserObjectInformationW
GetLastActivePopup
GetActiveWindow
MessageBoxW
USER32.DLL
CONOUT$
CONFIG
brbconfig.tmp
YnJiYm90
uri
exec
file
conf
exit
sleep
encode
%2x
%02x
%s?i=%s&c=%s&p=%s
APPDATA
Software\Microsoft\Windows\CurrentVersion\Run
brbbot

<SNIP>

RegSetValueExA
RegOpenKeyExA
RegDeleteValueA
RegFlushKey
RegCloseKey
CryptAcquireContextW
CryptDeriveKey
CryptReleaseContext
CryptEncrypt
CryptCreateHash
CryptDestroyKey
CryptDecrypt
CryptDestroyHash
CryptHashData
ADVAPI32.dll
InternetQueryDataAvailable
InternetReadFile
InternetCloseHandle
HttpQueryInfoA
InternetConnectA
InternetSetOptionA
HttpOpenRequestA
HttpSendRequestA
InternetOpenA
WININET.dll
WS2_32.dll
CreateFileA
FindResourceA
LoadResource
HeapAlloc
HeapFree
GetProcessHeap
WriteFile
SizeofResource
GetLastError
LockResource
GetModuleHandleA
CloseHandle
GetComputerNameA
HeapReAlloc
MoveFileExA
WaitForSingleObject
SetEvent
GetModuleHandleW
GetSystemWow64DirectoryA
CreateProcessA
GetSystemDirectoryA
GetEnvironmentVariableA
CopyFileA
CreateEventW
GetModuleFileNameA
DeleteFileA
GetFileSize
ReadFile
WideCharToMultiByte
GetProcAddress
GetTempFileNameA
GetTempPathA
KERNEL32.dll
GetDC
USER32.dll
GetCommandLineW
GetStartupInfoW
TerminateProcess
GetCurrentProcess
UnhandledExceptionFilter
SetUnhandledExceptionFilter
IsDebuggerPresent
RtlVirtualUnwind
RtlLookupFunctionEntry
RtlCaptureContext
EncodePointer
DecodePointer
GetCPInfo
GetACP
GetOEMCP
IsValidCodePage
FlsGetValue
FlsSetValue
FlsFree
SetLastError
GetCurrentThreadId
FlsAlloc
ExitProcess
GetStdHandle
GetModuleFileNameW
RtlUnwindEx
FreeEnvironmentStringsW
GetEnvironmentStringsW
SetHandleCount
InitializeCriticalSectionAndSpinCount
GetFileType
DeleteCriticalSection
HeapSetInformation
GetVersion
HeapCreate
QueryPerformanceCounter
GetTickCount
GetCurrentProcessId
GetSystemTimeAsFileTime
Sleep
MultiByteToWideChar
SetFilePointer
GetConsoleCP
GetConsoleMode
EnterCriticalSection
LeaveCriticalSection
LCMapStringW
GetStringTypeW
LoadLibraryW
SetStdHandle
WriteConsoleW
HeapSize
CreateFileW
FlushFileBuffers

<SNIP>
```

We can also get some important information from the `strings` command above. There is the string `brbconfig.tmp` which suggests the program might drop this as a temporary file, we can also see the `Software\Microsoft\Windows\CurrentVersion\Run` string which indicates the malware modifies this key for persistence, in addition we can see the WINAPI function names which can already give us some idea about the behavior of the malware.

From Wireshark we can see suspicious communication to the brb.3dtuts.by domain.
![[Pasted image 20240830075721.png]]

Loading the malware into IDA, the starting function is `wWinMain`, the start of the function seems like initialization tasks.
![[Pasted image 20240830080245.png]]

Let's go to the last subroutine `sub_140002550` which might be the main function, looking at it, its does appear to be, let's rename it to `assumed_main`.
![[Pasted image 20240830080352.png]]

First the function loads and initializes parameters, it then calls the `memset` function which is used to fill a contiguous block of memory with a specific value. The value passed is 0, the size is 103h bytes, and the starting address is of `var_127`. It calls this function twice with the same parameters. Let's rename this function to `load_value_into_file`, and the pointer variable to `possibleFileLocation`.

It then retrieves required models. if from the second retrieval `eax` is not 0, indicating an error, it jumps toward the end of the function.

Next the function preforms some kind of move operation on the file, and searches for the `\` character inside the file name (result is in rax) using the `strrchr` function, lets change the function to `search_for_char`. After that it will get the path for the WOW directory, a system directory that allows to store 32-bit shared code on 64-bit Windows.
![[Pasted image 20240830085154.png]]

It then checks for errors, jumps based on that, and changes the directory if needed.
![[Pasted image 20240830090033.png]]

Next it loads the address of the folder (from the buffer) to the `rdi` register, allocates memory on the heap, and jumps towards the end of the function if there is an error.
![[Pasted image 20240830090926.png]]

Next the file path is copied to the location in `rcx` and a string is appended to it. The file name "brbconfig.tmp" is then copied to the rcx register and gets deleted, it then also deletes the file that is in the address in the `rbx` register. After that the file is moved and the function opens the registry key "Software\Microsoft\Windows\CurrentVersion\Run".
![[Pasted image 20240830095110.png]]

If there are no errors opening the key, the function next deletes the named value `brbbot`, and writes all attributes of the previously specified key to the registry.
![[Pasted image 20240830095236.png]]

Finally it performs some cleaning up operations. Overall this function seems to be doing more of cleanup operation, and not much of the logic of the malware.

Let's now continue from the first function.

### sub_140002230 (set_registry_key_and_create_temp)

We can see the function opens the file (probably the temporary file) and searches for the '\' character.
![[Pasted image 20240830101855.png]]

It then gets the value of the `APPDATA` environment variable, if there are any errors in the process it jumps to the end of the function. It then searches for the substring in buffer inside the file name.
![[Pasted image 20240830102348.png]]

Later the function copies the buffer to the address in the rcx register, and adds a string to the end of the file. It then copies the file and jumps to the end if there is an error.
![[Pasted image 20240830103618.png]]

It then sets the value of the run registry key for persistence to brbroot.
![[Pasted image 20240830103911.png]]

If there is no error, it then writes the attributes of the key, and renames a file to brbconfig.tmp.
![[Pasted image 20240830104105.png]]

The function then closes the registry key and does other cleanup operations before exiting.

## sub_140001150 (write_bytes_to_file)

The function writes byte to the temporary file.
![[Pasted image 20240830104915.png]]

This is pretty much all the function does.

## sub_1400012E0 (initialize_strings)

Let's look at the call to the first subroutine `sub_140001000`.This function does some string operations on uri, like searching for substrings and characters. Let's rename it to `manipulate_string`. It calls the function with some more strings like "exec" and "file". Over all the purpose of the function seems to be initializing strings.

The starting function then checks for errors, and jumps to the end of the program if there is.

The next function seems to also be related to initialization tasks, let's rename it to init.

## sub_140001840 (read_bytes_from_server)

The function first checks if there is data available on the server, if there isn't it jumps to the end. It then allocates memory on the heap.
![[Pasted image 20240830114047.png]]

It then reads bytes in a loop until there is no more to read, if there is an error in reading the bytes it jumps to the end of the function.
![[Pasted image 20240830114650.png]]

The function finishes with manipulation of strings and cleaning operations.

## sub_140001FB0 (assumed_main)

The one before last function seems to be handling all the important operations, so let's rename it to `assumed_main`.

The function start by getting process information and checking for errors, if errors are detected it jumps all the way to the end.
![[Pasted image 20240830115515.png]]

The function then reads from a buffer in a loop, and calls one of two functions depending on the buffer.
![[Pasted image 20240830120146.png]]

### sub_140003100 (write_to_temp_file)

The function first gets the temporary file name, and creates the file.
![[Pasted image 20240830120643.png]]

The function then writes buffer to the file and creates a process.
![[Pasted image 20240830120813.png]]

Finally the subroutine moves the file, and does some cleaning operations.

### sub_140002940 (encrypt_and_write_data)

The function starts by creating the temporary file `brbconfig.tmp`.
![[Pasted image 20240830121110.png]]

It then tries to acquire access to cryptographic functionality, if not successful it jumps towards then end of the function.
![[Pasted image 20240830121439.png]]

Next it derives a key for the base data.
![[Pasted image 20240830121939.png]]

Finally it encrypts the data and write it to a file.
![[Pasted image 20240830122103.png]]

![[Pasted image 20240830122129.png]]

It finishes with some cleaning operations, including destroying the cryptographic key and hash.
![[Pasted image 20240830122258.png]]
\
Going to the symbols tab we can see the CryptDecrypt function exists.
![[Pasted image 20240830124655.png]]

We can put a breakpoint after this function to unveil the decrypted content of the temporary file.