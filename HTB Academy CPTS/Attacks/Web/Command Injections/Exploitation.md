## Detection

The process for basic detection of command injection vulnerabilities is the same as the process for exploiting such vulnerabilities. We attempt to append our command through various injection methods. If the command output changes from the intended usual result, we have successfully exploited the vulnerability. For more advanced command injection vulnerabilities, we may utilize various fuzzing methods or code reviews to identify them. We may then gradually build our payload until we achieve command injection.

We can check here if an IP is alive or not:
![[cmdinj_basic_exercise_1.jpg]]

When entering an IP address it returns the output of a ping command.

As the result shows a single packet transmitted in the ping command, the command used may be as follow:
```bash
ping -c 1 OUR_INPUT
```

If our input is not sanitized and escaped before it is used with the `ping` command, we may be able to inject another arbitrary command.

### Command Injection Methods

inject an additional command to the intended one, we may use any of the following operators:

| **Injection Operator** | **Injection Character** | **URL-Encoded Character** | **Executed Command**                       |
| ---------------------- | ----------------------- | ------------------------- | ------------------------------------------ |
| Semicolon              | `;`                     | `%3b`                     | Both                                       |
| New Line               | `\n`                    | `%0a`                     | Both                                       |
| Background             | `&`                     | `%26`                     | Both (second output generally shown first) |
| Pipe                   | `\|`                    | `%7c`                     | Both (only second output is shown)         |
| AND                    | `&&`                    | `%26%26`                  | Both (only if first succeeds)              |
| OR                     | `\|\|`                  | `%7c%7c`                  | Second (only if first fails)               |
| Sub-Shell              | ` `` `                  | `%60%60`                  | Both (Linux-only)                          |
| Sub-Shell              | `$()`                   | `%24%28%29`               | Both (Linux-only)                          |
|                        |                         |                           |                                            |
|                        |                         |                           |                                            |

`We would write our expected input (e.g., an IP), then use any of the above operators, and then write our new command.`

Tip: In addition to the above, there are a few unix-only operators, that would work on Linux and macOS, but would not work on Windows, such as wrapping our injected command with double backticks (` `` `) or with a sub-shell operator (`$()`).

In general, for basic command injection, all of these operators can be used for command injections `regardless of the web application language, framework, or back-end server`.

Note: The only exception may be the semi-colon `;`, which will not work if the command was being executed with `Windows Command Line (CMD)`, but would still work if it was being executed with `Windows PowerShell`.

## Injecting Commands

We can append a semicolon after our input, and then append our command, the final payload will be something like `127.0.0.1; whoami`, and the final command to be executed will be:
```bash
ping -c 1 127.0.0.1; whoami
```

![[cmdinj_basic_injection.jpg]]

The web application refused our input, since it's not an IP format, from the look of the error message it appears to come from the front-end. We can confirm this, by checking that no network requests are being made when pressing the check button.

`It is very common for developers only to perform input validation on the front-end while not validating or sanitizing the input on the back-end.` It can occur for example, because of two teams one for the front-end and one for the back-end, with the back-end team trusting the front-end team with input validation.

Front-end validations are usually not enough to prevent injections, as they can be very easily bypassed by sending custom HTTP requests directly to the back-end.

### Bypassing Front-End Validation

The easiest method to customize the HTTP requests, is to send them through a proxy and sending them to the repeater (burp).

Now when we send the same command and URL encode it, we get the desired output:
![[cmdinj_basic_repeater_2.jpg]]

## Other Injection Operators

### AND Operator

Our final payload would be `127.0.0.1 && whoami`, and the final executed command would be:
```bash
ping -c 1 127.0.0.1 && whoami
```

We will get the same output from this command.

## OR Operator

The `OR` (`||`) operator will execute the second command, only if the first one fails, it is useful in cases where we must break the first command.

If we'll use `127.0.0.1 || whoami`, only the first command will execute.

This is because of how `bash` commands work. As the first command returns exit code `0` indicating successful execution, the `bash` command stops and does not try the other command. It would only attempt to execute the other command if the first command failed and returned an exit code `1`.

We can intentionally break the first command, by not supplying an IP:
```shell-session
$ ping -c 1 || whoami
```

Here the second command got executed successfully, with a cleaner result of just the second command:
![[cmdinj_basic_OR.jpg]]

Such operators can be used for various injection types, like SQL injections, LDAP injections, XSS, SSRF, XML, etc. We have created a list of the most common operators that can be used for injections:

| **Injection Type**                      | **Operators**                                     |
| --------------------------------------- | ------------------------------------------------- |
| SQL Injection                           | `'` `,` `;` `--` `/* */`                          |
| Command Injection                       | `;` `&&`                                          |
| LDAP Injection                          | `*` `(` `)` `&` `\|`                              |
| XPath Injection                         | `'` `or` `and` `not` `substring` `concat` `count` |
| OS Command Injection                    | `;` `&` `\|`                                      |
| Code Injection                          | `'` `;` `--` `/* */` `$()` `${}` `#{}` `%{}` `^`  |
| Directory Traversal/File Path Traversal | `../` `..\\` `%00`                                |
| Object Injection                        | `;` `&` `\|`                                      |
| XQuery Injection                        | `'` `;` `--` `/* */`                              |
| Shellcode Injection                     | `\x` `\u` `%u` `%n`                               |
| Header Injection                        | `\n` `\r\n` `\t` `%0d` `%0a` `%09`                |

Keep in mind that this table is incomplete, and many other options and operators are possible. It also highly depends on the environment we are working with and testing.

For more on advanced command injections, like indirect injections or blind injection, you may refer to the [Whitebox Pentesting 101: Command Injection](https://academy.hackthebox.com/course/preview/whitebox-pentesting-101-command-injection) module, which covers advanced injections methods and many other topics.